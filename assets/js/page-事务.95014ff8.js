(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{1020:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this.$createElement;return(this._self._c||v)("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}})}),[],!1,null,null,null);_.default=t.exports},648:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"事务"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),l("p",[v._v("：transaction ，指用户对数据库的一次操作。")]),v._v(" "),l("ul",[l("li",[v._v("一个事务可能是一个简单的读操作、写操作，也可能包含多个命令。")])]),v._v(" "),l("h2",{attrs:{id:"acid"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#acid"}},[v._v("#")]),v._v(" ACID")]),v._v(" "),l("p",[v._v("为了避免执行事务时出错，数据库应该实现事务的 ACID 四种特性。")]),v._v(" "),l("ul",[l("li",[v._v("原子性（Atomicity）\n"),l("ul",[l("li",[v._v("：一个事务是像原子一样的基本单元，不能拆分。要么完成，要么不完成，不存在其它状态。")]),v._v(" "),l("li",[v._v("为了保证原子性，当一个事务执行失败时，数据库应该恢复到执行之前的原状态。")])])]),v._v(" "),l("li",[v._v("一致性（Consistency）\n"),l("ul",[l("li",[v._v("：当多个用户同时访问数据库时，读取到的数据是完全相同的。")]),v._v(" "),l("li",[v._v("通过并发锁可以让并发事务变成串行事务，保证一致性，但会降低并发性能。")]),v._v(" "),l("li",[v._v("数据库本身可以阻止用户查看尚未同步的数据，从而保证一致性。")])])]),v._v(" "),l("li",[v._v("隔离性（Isolation）\n"),l("ul",[l("li",[v._v("：各个事务之间相互隔离。当一个事务执行失败时，不会影响到其它事务。")]),v._v(" "),l("li",[v._v("隔离一个执行失败的事务有两种策略：乐观、悲观。")])])]),v._v(" "),l("li",[v._v("持久性（Durability）\n"),l("ul",[l("li",[v._v("：一个成功完成的事务会对数据库造成持久的影响（主要是指写入的数据不会丢失），只可能被后续事务的影响覆盖。")])])])]),v._v(" "),l("h2",{attrs:{id:"并发事务"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#并发事务"}},[v._v("#")]),v._v(" 并发事务")]),v._v(" "),l("h3",{attrs:{id:"常见问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[v._v("#")]),v._v(" 常见问题")]),v._v(" "),l("p",[v._v("多个事务同时操作同一个数据时，可能引发以下并发问题：")]),v._v(" "),l("ul",[l("li",[v._v("丢失更新（Lost Update）\n"),l("ul",[l("li",[v._v("：多个事务同时修改数据时，后提交的事务覆盖了先提交的事务的修改。")]),v._v(" "),l("li",[v._v("第一类情况：事务 A 读取到数据的值为 10 ，加一之后提交为 11 。同时事务 B 也读取到该数据的值为 10 ，经过任意修改之后又回滚为 10 ，并且在事务 A 之后提交，使得该数据最终保存为 10 。")]),v._v(" "),l("li",[v._v("第二类情况：事务 A 读取到数据的值为 10 ，加一之后提交为 11 。同时事务 B 也读取到该数据的值为 10 ，减一之后提交为 9 ，并且在事务 A 之后提交，使得该数据最终保存为 9 。")])])]),v._v(" "),l("li",[v._v("脏读（Dirty Read）\n"),l("ul",[l("li",[v._v("：当事务 A 修改了数据但尚未提交时，其它事务可能读取到被修改之后的该数据。如果事务 A 放弃提交，则其它事务读到的数据就是错的。")])])]),v._v(" "),l("li",[v._v("不可重复读（Unrepeatable Read）\n"),l("ul",[l("li",[v._v("：如果事务 B 对同一条数据进行了两次读操作，且在这两次读操作之间，该数据被修改了，就会导致事务 B 两次读取到的数据不同。")])])]),v._v(" "),l("li",[v._v("幻读（Phantom Read）\n"),l("ul",[l("li",[v._v("：如果事务 B 对同一范围的数据进行了两次读操作，且在这两次读操作之间，该范围内新增了数据，就会导致事务 B 第二次读取到突然出现的新数据。")])])])]),v._v(" "),l("h3",{attrs:{id:"隔离级别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[v._v("#")]),v._v(" 隔离级别")]),v._v(" "),l("p",[v._v("SQL 标准定义了 4 种并发事务的隔离级别，从低到高排列如下：")]),v._v(" "),l("ul",[l("li",[v._v("读取未提交内容（Read Uncommitted）\n"),l("ul",[l("li",[v._v("：当事务修改了数据但尚未提交时，允许其它事务读取被修改之后的该数据。")]),v._v(" "),l("li",[v._v('这种隔离级别最不安全，能避免 "丢失更新" 的问题，但不能避免 "脏读" 、 "不可重复读" 、 "幻读" 的问题。')])])]),v._v(" "),l("li",[v._v("读取已提交内容（Read Committed）\n"),l("ul",[l("li",[v._v("：当事务修改了数据且提交之后，才允许其它事务读取被修改之后的该数据，否则看到的是原数据。")]),v._v(" "),l("li",[v._v('不能避免 "不可重复读" 、 "幻读" 的问题。')]),v._v(" "),l("li",[v._v("这是大部分数据库的默认隔离级别。")])])]),v._v(" "),l("li",[v._v("可重复读（Repeatable Read）\n"),l("ul",[l("li",[v._v("：保证一个事务在执行期间对同一数据的多次读取结果相同。")]),v._v(" "),l("li",[v._v('不能避免 "幻读" 的问题。')]),v._v(" "),l("li",[v._v('这是 MySQL 的默认隔离级别，并且 InnoDB 引擎通过多版本并发控制（Mutil-Version Concurrency Control ，MVCC）解决了 "幻读" 的问题。')])])]),v._v(" "),l("li",[v._v("可串行化（Serializable）\n"),l("ul",[l("li",[v._v("：当一个事务对数据进行写操作时，不允许其它事务对该数据进行读操作、写操作。（即加上排它锁）")]),v._v(" "),l("li",[v._v("这种隔离级别最安全，但是事务的执行速度最慢。")])])])]),v._v(" "),l("h3",{attrs:{id:"数据库锁"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据库锁"}},[v._v("#")]),v._v(" 数据库锁")]),v._v(" "),l("p",[v._v("为了避免并发事务产生冲突，一个事务可以在读写数据之前对数据加锁，限制其它事务对该数据的操作，等操作完数据之后再释放锁。")]),v._v(" "),l("ul",[l("li",[v._v("使用场景：\n"),l("ul",[l("li",[v._v("如果当前事务是读取数据，其它事务也只是读取数据，则一般不需要加锁。")]),v._v(" "),l("li",[v._v("如果当前事务是读取数据，其它事务可能修改数据，则应该加锁来保护当前事务。")]),v._v(" "),l("li",[v._v("如果当前事务是修改数据，则应该加锁来保护其它事务。")])])]),v._v(" "),l("li",[v._v("如果数据库没有提供合适的锁机制，就需要用户自己编程实现，限制客户端的行为。")]),v._v(" "),l("li",[v._v("数据库的权限、外键、锁等功能主要是用于限制用户的操作。但一般的数据库软件只能提供少量的限制功能，不能满足复杂的业务逻辑。\n"),l("ul",[l("li",[v._v("应该尽量在客户端处限制用户的操作，只将合理的操作请求发送给数据库，从而降低数据库的复杂度、开销。")])])])]),v._v(" "),l("p",[v._v("按严格程度分类：")]),v._v(" "),l("ul",[l("li",[v._v("共享锁（Share Locks）：又称为 S 锁、只读锁。\n"),l("ul",[l("li",[v._v("允许所有事务读取该数据、加 S 锁，禁止所有事务修改该数据、加 X 锁。")])])]),v._v(" "),l("li",[v._v("排它锁（Exclusive Locks）：又称为 X 锁、写锁。\n"),l("ul",[l("li",[v._v("允许当前事务读取、修改该数据，禁止其它事务读取、修改该数据、加锁。")]),v._v(" "),l("li",[v._v("例如：事务 A 对数据加 X 锁之后，其它事务必须要等待事务 A 释放锁，才能操作该数据。")])])])]),v._v(" "),l("p",[v._v("按使用策略分类：")]),v._v(" "),l("ul",[l("li",[v._v("悲观锁：每次读取、修改数据时都加锁。\n"),l("ul",[l("li",[v._v("适用于经常修改数据的情况。")])])]),v._v(" "),l("li",[v._v("乐观锁：仅修改数据时加锁。\n"),l("ul",[l("li",[v._v("适用于很少修改数据的情况。")])])])]),v._v(" "),l("p",[v._v("按控制范围分类：")]),v._v(" "),l("ul",[l("li",[v._v("行级锁（row lock）")]),v._v(" "),l("li",[v._v("表级锁（table lock）")])]),v._v(" "),l("h3",{attrs:{id:"封锁协议"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#封锁协议"}},[v._v("#")]),v._v(" 封锁协议")]),v._v(" "),l("p",[v._v("：指 S 锁、X 锁的一些基本用法。")]),v._v(" "),l("ul",[l("li",[v._v("一级封锁协议\n"),l("ul",[l("li",[v._v("：要求事务在修改数据之前必须加 X 锁，直到事务结束才能释放锁。")]),v._v(" "),l("li",[v._v('能避免 "丢失更新" 的问题。')])])]),v._v(" "),l("li",[v._v("二级封锁协议\n"),l("ul",[l("li",[v._v("：在一级的基础上，要求事务在读取数据之前必须加 S 锁，直到读取结束才能释放锁。")]),v._v(" "),l("li",[v._v('能避免 "丢失更新" 、 "脏读" 的问题。')])])]),v._v(" "),l("li",[v._v("三级封锁协议\n"),l("ul",[l("li",[v._v("：在二级的基础上，要求事务在读取数据之前必须加 S 锁，直到事务结束才能释放锁。")]),v._v(" "),l("li",[v._v('能避免 "丢失更新" 、 "脏读" 、 "不可重复读" 的问题。')])])]),v._v(" "),l("li",[v._v("两段锁协议\n"),l("ul",[l("li",[v._v("：将事务的执行时期分为前后两个阶段，在前一个阶段只能加锁、不能释放锁，在后一个阶段只能释放锁、不能加锁。")]),v._v(" "),l("li",[v._v('两段锁协议是实现 "可串行化" 隔离级别的充分条件。')]),v._v(" "),l("li",[v._v("MySQL 的 InnoDB 引擎就是采用两段锁协议，根据隔离级别自动加锁，并同时释放所有锁。")])])])]),v._v(" "),l("h3",{attrs:{id:"活锁、死锁"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#活锁、死锁"}},[v._v("#")]),v._v(" 活锁、死锁")]),v._v(" "),l("p",[v._v("使用数据库锁时可能产生活锁、死锁的问题。")]),v._v(" "),l("ul",[l("li",[v._v("活锁\n"),l("ul",[l("li",[v._v("例：事务 A、B、C 先后请求对数据加锁，数据库系统先把锁分配给事务 A ，然后却分配给事务 C ，导致事务 B 多等待了一段时间，甚至一直等待下去。")]),v._v(" "),l("li",[v._v("解决方法：\n"),l("ul",[l("li",[v._v("要求数据库系统按先来后到的顺序分配锁。")])])])])]),v._v(" "),l("li",[v._v("死锁\n"),l("ul",[l("li",[v._v("例：事务 A 对数据 m 加锁之后，申请对数据 n 加锁，事务 B 对数据 n 加锁之后，申请对数据 m 加锁。这会导致两个事务都在等待获取对方数据的锁，一直僵持下去。")]),v._v(" "),l("li",[v._v("解决方法：\n"),l("ul",[l("li",[v._v("如果总共需要锁住的数据不多，可以让每个事务都一次性申请所有锁。")]),v._v(" "),l("li",[v._v("如果总共需要申请的锁不多，可以让每个事务都按特定顺序申请锁。")]),v._v(" "),l("li",[v._v("检查事务的执行时间，如果超时过久就可能是产生了死锁，需要人工排除。")])])])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);