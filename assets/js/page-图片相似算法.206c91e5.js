(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{786:function(v,_,a){"use strict";a.r(_);var l=a(1),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"图片相似算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片相似算法"}},[v._v("#")]),v._v(" 图片相似算法")]),v._v(" "),a("ul",[a("li",[v._v("根据 MD5 等加密哈希算法可以判断两张图片是否为同一文件，但不能判断两张图片的相似度。因此应该使用专门的图片相似算法。")]),v._v(" "),a("li",[v._v("使用图片相似算法的一般步骤：\n"),a("ol",[a("li",[v._v("缩小图片的分辨率、减少颜色通道数，以便简化分析。")]),v._v(" "),a("li",[v._v("按某种算法计算出每张图片的特征值，再根据两个特征值的汉明距离判断图片的相似度。")]),v._v(" "),a("li",[v._v("相似度 = 1 - ( 汉明距离 / 特征值长度 )")])])]),v._v(" "),a("li",[v._v("汉明距离（Hamming Distance）：两个长度相同的字符串之间，取值不同的对应位的数量，类似于异或运算。")]),v._v(" "),a("li",[v._v("衡量图片相似算法的指标：\n"),a("ul",[a("li",[v._v("能否识别内容相似、只是有细节差异的图片。")]),v._v(" "),a("li",[v._v("能否识别内容相似、但分辨率不同的图片。")]),v._v(" "),a("li",[v._v("能否识别内容相似、只是颜色不同的图片。")]),v._v(" "),a("li",[v._v("判断相似度的准确性。")]),v._v(" "),a("li",[v._v("处理图片的耗时。")])])])]),v._v(" "),a("h2",{attrs:{id:"内容特征法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容特征法"}},[v._v("#")]),v._v(" 内容特征法")]),v._v(" "),a("ul",[a("li",[v._v("原理：\n"),a("ol",[a("li",[v._v("在色阶 0~255 中选择一个阙值，将图片从灰度图转换成黑白图。比如如果像素点的灰度值低于 150 则转换成黑色，否则转换成白色。")]),v._v(" "),a("li",[v._v("如果两张图片的黑白轮廓相似，则认为它们的内容也相似。")])])])]),v._v(" "),a("h2",{attrs:{id:"颜色分布法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#颜色分布法"}},[v._v("#")]),v._v(" 颜色分布法")]),v._v(" "),a("ul",[a("li",[v._v("原理：\n"),a("ol",[a("li",[v._v("生成图片的颜色分布的直方图（color histogram）。比如 RGB 三色分别生成直方图，再合并成一个直方图。")]),v._v(" "),a("li",[v._v("如果两张图片的直方图相似，则认为它们的内容也相似。")])])])]),v._v(" "),a("h2",{attrs:{id:"ahash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ahash"}},[v._v("#")]),v._v(" aHash")]),v._v(" "),a("p",[v._v("：平均哈希算法（average Hash）")]),v._v(" "),a("ul",[a("li",[v._v("原理：\n"),a("ol",[a("li",[v._v("将图片缩小到 8×8 分辨率。（这样就只需考虑 64 个像素点）")]),v._v(" "),a("li",[v._v("将图片转换成灰度图。（这样就只需考虑一个颜色通道）")]),v._v(" "),a("li",[v._v("计算 64 个像素点的灰度平均值。")]),v._v(" "),a("li",[v._v("将每个像素点的灰度值与平均值作比较，如果大于或等于平均值则计 1 ，否则计 0 。最后得到一个 64 位的哈希值。")])])]),v._v(" "),a("li",[v._v("特点：\n"),a("ul",[a("li",[v._v("不考虑图片细节的差异，适合计算缩略图的哈希值。")]),v._v(" "),a("li",[v._v("不能适应图片分辨率的变化。将同一张图片放大、缩小，aHash 值会变化很大。")])])])]),v._v(" "),a("h2",{attrs:{id:"dhash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dhash"}},[v._v("#")]),v._v(" dHash")]),v._v(" "),a("p",[v._v("：梯度哈希算法（difference Hash）")]),v._v(" "),a("ul",[a("li",[v._v("原理：\n"),a("ol",[a("li",[v._v("将图片缩小到 9×8 辨率。")]),v._v(" "),a("li",[v._v("转换成灰度图。")]),v._v(" "),a("li",[v._v("比较每对相邻像素点的灰度值，如果前一个像素点的灰度值大于等于后一个像素点则记 1 。否则计 0 。最后得到一个 64 位的哈希值。\n"),a("ul",[a("li",[v._v("比如[254, 254, 255, 253]的计算结果为[1, 0, 1]。")])])])])])]),v._v(" "),a("h2",{attrs:{id:"phash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phash"}},[v._v("#")]),v._v(" pHash")]),v._v(" "),a("p",[v._v("：感知哈希算法（perception Hash）")]),v._v(" "),a("ul",[a("li",[v._v("基于离散余弦变换（DCT）。")]),v._v(" "),a("li",[v._v("原理：\n"),a("ol",[a("li",[v._v("将图片缩小到指定分辨率。")]),v._v(" "),a("li",[v._v("转换成灰度图。")]),v._v(" "),a("li",[v._v("计算灰度图的 DCT 变换，得到一个 32×32 的 DCT 矩阵。可以只取矩阵左上角的 8×8 部分，计算其平均值。")]),v._v(" "),a("li",[v._v("将每个像素点的灰度值与平均值作比较，如果大于或等于平均值则计 1 ，否则计 0 。最后得到一个 64 位的哈希值。")])])]),v._v(" "),a("li",[v._v("特点：\n"),a("ul",[a("li",[v._v("能考虑到图片细节的差异。")]),v._v(" "),a("li",[v._v("计算比较慢。")]),v._v(" "),a("li",[v._v("还能计算音频，视频文件的哈希值。")])])])]),v._v(" "),a("h2",{attrs:{id:"whash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#whash"}},[v._v("#")]),v._v(" wHash")]),v._v(" "),a("p",[v._v("：小波哈希算法（wavelet Hash）")]),v._v(" "),a("ul",[a("li",[v._v("基于离散小波变换（DWT）。")])]),v._v(" "),a("h2",{attrs:{id:"sift"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sift"}},[v._v("#")]),v._v(" SIFT")]),v._v(" "),a("p",[v._v("：尺度不变特征转换算法（Scale-Invariant Feature Transform）")]),v._v(" "),a("ul",[a("li",[v._v("特点：\n"),a("ul",[a("li",[v._v("能适应图片分辨率的变化。")]),v._v(" "),a("li",[v._v("能适应图片的旋转。")])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);