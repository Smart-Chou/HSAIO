(window.webpackJsonp=window.webpackJsonp||[]).push([[366],{671:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("运行多个进程时，隔离它们的运行环境有利于管理。常见的几种隔离方式：")]),v._v(" "),t("ul",[t("li",[v._v("运行多个物理主机\n"),t("ul",[t("li",[v._v("缺点：冗余大，不方便通过软件管理")])])]),v._v(" "),t("li",[v._v("在物理机上运行多个虚拟机")]),v._v(" "),t("li",[v._v("在主机上运行多个容器，每个容器内包含一组进程")])]),v._v(" "),t("h2",{attrs:{id:"虚拟机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机"}},[v._v("#")]),v._v(" 虚拟机")]),v._v(" "),t("p",[v._v("：Hypervisor ，又称为 VMM（Virtual Machine Monitor ，虚拟机监视器）")]),v._v(" "),t("ul",[t("li",[v._v("原理：\n"),t("ul",[t("li",[v._v("在计算机硬件与操作系统之间隔离出一个中间层，用于运行虚拟化的操作系统。")])])]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("实现了对整个操作系统的隔离。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("重量级\n"),t("ul",[t("li",[v._v("运行虚拟机软件，大概消耗 10% 的系统资源。")]),v._v(" "),t("li",[v._v("每个虚拟机要运行一个完整的操作系统，但应用程序一般只需要用到其中少量的功能服务、系统资源，因此冗余较多。")]),v._v(" "),t("li",[v._v("部署一个应用程序时，需要先创建一个虚拟机、安装操作系统，再配置运行环境、拷贝应用程序，耗时为几小时。")])])])])]),v._v(" "),t("li",[v._v("创建虚拟机的软件举例：\n"),t("ul",[t("li",[v._v("Xen\n"),t("ul",[t("li",[v._v("2003 年发布。")])])]),v._v(" "),t("li",[v._v("OpenVZ\n"),t("ul",[t("li",[v._v("2005 年发布。")]),v._v(" "),t("li",[v._v("在底层操作系统上运行多个虚拟操作系统，共用一个内核。")]),v._v(" "),t("li",[v._v("只支持 Linux 系统。")])])]),v._v(" "),t("li",[v._v("KVM（Kernel-based Virtual Machine）\n"),t("ul",[t("li",[v._v("2006 年发布。")]),v._v(" "),t("li",[v._v("每个虚拟操作系统使用一个独立的内核，因此可采用不同的操作系统。")]),v._v(" "),t("li",[v._v("OpenVZ 属于半虚拟化，而 KVM 属于全虚拟化，开销更大。")])])]),v._v(" "),t("li",[v._v("VirtualBox")]),v._v(" "),t("li",[v._v("VMwareWorkstation")]),v._v(" "),t("li",[v._v("Windows Hyper-V")])])])]),v._v(" "),t("h2",{attrs:{id:"容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[v._v("#")]),v._v(" 容器")]),v._v(" "),t("p",[v._v("：Container ，新一代的虚拟化技术。")]),v._v(" "),t("ul",[t("li",[v._v("原理：\n"),t("ul",[t("li",[v._v("在应用程序与操作系统之间隔离出一个中间层，用于运行容器。")]),v._v(" "),t("li",[v._v("以镜像作为模板，在主机上创建容器并保持运行。\n"),t("ul",[t("li",[v._v("运行容器的主机称为宿主机，可以是物理机或虚拟机。")])])])])]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("能隔离进程的运行环境\n"),t("ul",[t("li",[v._v("隔离程度比虚拟机低，比如容器会共享宿主机内核，但足够满足一般项目的需求。")])])]),v._v(" "),t("li",[v._v("便于管理进程\n"),t("ul",[t("li",[v._v("包含了进程管理工具的功能，比如启动、停止、自动重启。")]),v._v(" "),t("li",[v._v("进程及其子进程都运行在容器中，不会游离到容器外。")])])]),v._v(" "),t("li",[v._v("轻量级\n"),t("ul",[t("li",[v._v("运行容器引擎，大概只消耗 5% 的系统资源。")]),v._v(" "),t("li",[v._v("部署一个应用时，直接启动一个容器即可，耗时为几秒。")])])]),v._v(" "),t("li",[v._v("兼容性好\n"),t("ul",[t("li",[v._v("同一个镜像可以拷贝到不同平台上，创建容器，只需系统内核相同。")]),v._v(" "),t("li",[v._v("便于将应用迁移部署到其它主机。")])])])])]),v._v(" "),t("li",[v._v("总之，容器能在一般场景下模拟虚拟机，更轻量级，但不能完全替代虚拟机。")])]),v._v(" "),t("h3",{attrs:{id:"相关历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关历史"}},[v._v("#")]),v._v(" 相关历史")]),v._v(" "),t("ul",[t("li",[v._v("1979 年，Unix 系统加入了 chroot 技术（change root directory），用于更改正在运行的进程的根目录。\n"),t("ul",[t("li",[v._v("这里是指文件系统的根目录，不是指当前的工作目录。")]),v._v(" "),t("li",[v._v("更改根目录时，需要先拷贝 /lib 等库文件到新的根目录下，供进程调用。")])])]),v._v(" "),t("li",[v._v("2002 年，Linux 系统加入了 namespace 技术，用于隔离进程可见、可用的系统资源。")]),v._v(" "),t("li",[v._v("2008 年，Linux 系统加入了 Control group 技术，简称为 Cgroup ，用于限制进程占用的 CPU、内存等系统资源。")]),v._v(" "),t("li",[v._v("2008 年，Linux 系统加入了 LXC 工具，用于控制 namespace 和 Cgroup 。")]),v._v(" "),t("li",[v._v("2013 年，dotCloud 公司于发布 Docker 软件，使得容器技术流行、普及，公司也改名为 Docker 公司。")])]),v._v(" "),t("h3",{attrs:{id:"容器引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器引擎"}},[v._v("#")]),v._v(" 容器引擎")]),v._v(" "),t("ul",[t("li",[v._v("容器引擎（Container Engine）：通常是一个复杂的软件，负责与用户交互、管理镜像、管理容器。")]),v._v(" "),t("li",[v._v("容器引擎举例：\n"),t("ul",[t("li",[v._v("LXC（Linux Container）")]),v._v(" "),t("li",[v._v("Docker")]),v._v(" "),t("li",[v._v("Podman ：兼容 Docker CLI 的大部分命令。")]),v._v(" "),t("li",[v._v("Windows Hyper-V Containers")])])])]),v._v(" "),t("h3",{attrs:{id:"容器运行时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器运行时"}},[v._v("#")]),v._v(" 容器运行时")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("容器运行时（Container Runtime）：通常是一个 CLI 程序，用于创建、运行、管理容器。")]),v._v(" "),t("ul",[t("li",[v._v("有的容器引擎会直接管理容器，而有的容器引擎会调用容器运行时来管理容器。")]),v._v(" "),t("li",[v._v("早期版本的 Docker 引擎是通过 LXC 来控制 namespace、Cgroup ，实现容器化。从 0.9 版本开始，弃用 LXC ，改用 libcontainer 等 Golang 库，后来演变为 runC 组件。\n"),t("ul",[t("li",[v._v("2016 年，Docker 引擎将其底层组件 runC、containerd 抽离出来，成为独立的容器运行时项目。")]),v._v(" "),t("li",[v._v("此后，Docker 引擎会调用 containerd 来管理容器，而 containerd 会调用 runC ，runC 才会直接管理容器。")])])])])]),v._v(" "),t("li",[t("p",[v._v("OCI（Open Container Initiative ，开放容器倡议）")]),v._v(" "),t("ul",[t("li",[v._v("该组织于 2015 年创立，负责制定容器行业的镜像规范、容器运行时规范。")]),v._v(" "),t("li",[v._v("如果一个镜像符合 OCI 规范，则可以被符合 OCI 标准的容器运行时用于创建容器。")])])]),v._v(" "),t("li",[t("p",[v._v("底层的容器运行时：")]),v._v(" "),t("ul",[t("li",[v._v("runC\n"),t("ul",[t("li",[v._v("只支持 Linux 系统。")])])]),v._v(" "),t("li",[v._v("crun")]),v._v(" "),t("li",[v._v("rkt（CoreOS Rocket）\n"),t("ul",[t("li",[v._v("由 CoreOS 团队发布，以 Pod 为单位管理容器。但不符合 OCI 规范，已被弃用。")])])]),v._v(" "),t("li",[v._v("kata-containers\n"),t("ul",[t("li",[v._v("在一个轻量级虚拟机中运行容器，不共享宿主机的内核，隔离程度更高。")])])])])]),v._v(" "),t("li",[t("p",[v._v("高层的容器运行时：基于 runC 等底层的容器运行时来管理容器。例如：")]),v._v(" "),t("ul",[t("li",[v._v("containerd\n"),t("ul",[t("li",[v._v("支持 Linux、Windows 系统。")]),v._v(" "),t("li",[v._v("支持 k8s 的 CRI 接口。")])])]),v._v(" "),t("li",[v._v("CRI-O\n"),t("ul",[t("li",[v._v("主要用于将底层的容器运行时对接到 k8s CRI 接口。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"容器编排工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器编排工具"}},[v._v("#")]),v._v(" 容器编排工具")]),v._v(" "),t("p",[v._v("当容器数量较多时，手动管理很麻烦，需要使用容器编排工具，例如：")]),v._v(" "),t("ul",[t("li",[v._v("Docker Compose ：由 Docker 公司发布，只能管理当前宿主机上的容器，不能管理服务器集群。")]),v._v(" "),t("li",[v._v("Docker Swarm ：由 Docker 公司发布，在 docker 软件包中自带，可以管理多台宿主机上的容器。")]),v._v(" "),t("li",[v._v("Mesos ：由 ASF 管理。")]),v._v(" "),t("li",[v._v("k8s ：由 Google 公司发布，功能多但也复杂，通过命令行操作。")])])])}),[],!1,null,null,null);_.default=l.exports},689:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"监控工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控工具"}},[v._v("#")]),v._v(" 监控工具")]),v._v(" "),t("ul",[t("li",[v._v("Zabbix ：于 2001 年发布。")]),v._v(" "),t("li",[v._v("Nagios ：于 2002 年发布。")]),v._v(" "),t("li",[v._v("Graphite ：于 2008 年发布。")]),v._v(" "),t("li",[v._v("Datadog ：于 2009 年发布。")]),v._v(" "),t("li",[v._v("Promethues ：于 2015 年发布。")]),v._v(" "),t("li",[v._v("Open-Falcon ：于 2015 年由小米公司开源，采用 Golang 开发。")]),v._v(" "),t("li",[v._v("Grafana ：于 2014 年发布。不能采集监控数据，只负责显示监控图表，通常与 MySQL、InfluxDB、Promethues 等监控数据源组合使用。")])]),v._v(" "),t("h2",{attrs:{id:"监控策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控策略"}},[v._v("#")]),v._v(" 监控策略")]),v._v(" "),t("ul",[t("li",[v._v("采用自动化的监控工具取代人工巡检，可以更直观地查看系统状态、记录日志，更及时地发现异常。")]),v._v(" "),t("li",[v._v("有的监控指标可能平时不会关注，如果开销不大，则应该也记录下来，有备无患。")]),v._v(" "),t("li",[v._v("从多个层面进行监控：\n"),t("ul",[t("li",[v._v("服务器状态：比如 CPU 使用率、IO 速率、Socket 数量。")]),v._v(" "),t("li",[v._v("进程外部状态：比如进程数、CPU 使用率。")]),v._v(" "),t("li",[v._v("进程内部状态：比如异常数、日志中是否报错。")]),v._v(" "),t("li",[v._v("中间件状态：即 MySQL、Redis 等中间件的内部状态。流行的中间件一般能自己提供这些监控信息。")]),v._v(" "),t("li",[v._v("业务状态：比如用户数、请求数、响应速度。")])])]),v._v(" "),t("li",[v._v("显示监控指标的几种图表：\n"),t("ul",[t("li",[v._v("文本")]),v._v(" "),t("li",[v._v("曲线图：适合每秒都在变化的指标。")]),v._v(" "),t("li",[v._v("条状图：适合几分钟才变化一次的指标。")]),v._v(" "),t("li",[v._v("饼状图：适合总量固定的多个指标，表示百分比关系。")])])]),v._v(" "),t("li",[v._v("将不同的监控指标用不同的颜色标明：\n"),t("ul",[t("li",[v._v("绿色：代表良好状态，或者取值越大越好的指标。")]),v._v(" "),t("li",[v._v("灰色：代表不需要关注。")]),v._v(" "),t("li",[v._v("蓝色：代表正常状态，但是取值越小越好的指标。")]),v._v(" "),t("li",[v._v("黄色：代表轻微异常，可以忽视。")]),v._v(" "),t("li",[v._v("橙色：代表明显异常，需要处理，但并不紧急。")]),v._v(" "),t("li",[v._v("红色：代表危险状态，需要立即处理。")])])])]),v._v(" "),t("h2",{attrs:{id:"告警策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#告警策略"}},[v._v("#")]),v._v(" 告警策略")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("当监控系统发现某个指标的值不符合预期时，应该标识为异常状态，并发送警报（Alert）。")])]),v._v(" "),t("li",[t("p",[v._v("发送警报的策略：")]),v._v(" "),t("ul",[t("li",[v._v("允许暂停发送警报，便于调试。")]),v._v(" "),t("li",[v._v("在 m 时长内 n 次满足告警条件，才发送警报，从而减少误报。")]),v._v(" "),t("li",[v._v("发送一个警报之后，如果一直满足告警条件，则需要间隔一段时间才能重复发送，从而避免告警风暴。")]),v._v(" "),t("li",[v._v("尽量对警报去重，比如同一应用的不同实例共用一个警报、同一对象的严重警报会覆盖不严重警报。")]),v._v(" "),t("li",[v._v("当告警解除时，应该再发送一个消息通知用户。")])])]),v._v(" "),t("li",[t("p",[v._v("应该为警报划分几种严重等级，例如：")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("等级")]),v._v(" "),t("th",[v._v("含义")]),v._v(" "),t("th",[v._v("处理措施")]),v._v(" "),t("th",[v._v("通知人")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("FATAL")]),v._v(" "),t("td",[v._v("很严重")]),v._v(" "),t("td",[v._v("应该立即处理，紧急")]),v._v(" "),t("td",[v._v("发送邮件+短信给相关负责人，甚至更高级的负责人")])]),v._v(" "),t("tr",[t("td",[v._v("ERROR")]),v._v(" "),t("td",[v._v("错误")]),v._v(" "),t("td",[v._v("需要处理，但并不紧急")]),v._v(" "),t("td",[v._v("发送邮件给相关负责人")])]),v._v(" "),t("tr",[t("td",[v._v("WARN")]),v._v(" "),t("td",[v._v("警告")]),v._v(" "),t("td",[v._v("不一定要处理")]),v._v(" "),t("td",[v._v("发送邮件给相关负责人")])]),v._v(" "),t("tr",[t("td",[v._v("INFO")]),v._v(" "),t("td",[v._v("提示")]),v._v(" "),t("td",[v._v("可以忽略，相当于日志")]),v._v(" "),t("td",[v._v("默认不会发送给用户")])])])])]),v._v(" "),t("li",[t("p",[v._v("平时查看警报的需求：")]),v._v(" "),t("ul",[t("li",[v._v("先查看当前存在的警报\n"),t("ul",[t("li",[v._v("先查看包含多个警报的简介列表，再点击单个警报查看其详情")])])]),v._v(" "),t("li",[v._v("再查看出现过的所有警报，并标明它们是否已处理")])])]),v._v(" "),t("li",[t("p",[v._v("处理警报的策略：")]),v._v(" "),t("ul",[t("li",[v._v("警报出现之后应该尽早解决，不要忽视警报而一直保留它，否则就失去了告警的意义。")]),v._v(" "),t("li",[v._v("对于经常重复出现的告警，可以尝试用脚本自动化解决，比如当进程异常退出时自动重启。")]),v._v(" "),t("li",[v._v("使用一个告警平台，统一接收不同来源的警报（比如 HTTP 、SMTP 方式的警报），然后按自定义的告警策略转发出去。")]),v._v(" "),t("li",[v._v("每条警报应该记录这些信息：简短标题、具体描述、开始时间、结束时间、负责人、处理人、处理方法。")])])])])])}),[],!1,null,null,null);_.default=l.exports},695:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"配置信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置信息"}},[v._v("#")]),v._v(" 配置信息")]),v._v(" "),t("p",[v._v("项目的配置信息分为多种，管理措施也不同：")]),v._v(" "),t("ul",[t("li",[v._v("源代码\n"),t("ul",[t("li",[v._v("用 Git 或 SVN 服务器管理。")])])]),v._v(" "),t("li",[v._v("运行环境\n"),t("ul",[t("li",[v._v("比如运行项目需要的操作系统、依赖软件。")]),v._v(" "),t("li",[v._v("如果项目部署在虚拟机上，可用 Ansible 批量管理主机。")]),v._v(" "),t("li",[v._v("如果项目部署在容器中，可用 Dockerfile 配置运行环境。")])])]),v._v(" "),t("li",[v._v("配置文件\n"),t("ul",[t("li",[v._v("有的项目没有准备配置文件，而是将配置信息直接写在代码中。这样不方便管理配置信息，仅适用于开发阶段。")]),v._v(" "),t("li",[v._v("配置文件可能包含服务器密码等敏感信息，因此不应该保存在项目的代码仓库中，否则会被所有人可见。")]),v._v(" "),t("li",[v._v("常见需求：\n"),t("ul",[t("li",[v._v("静态配置\n"),t("ul",[t("li",[v._v("：程序一般只需在启动时读取一次，不需要经常更新。")]),v._v(" "),t("li",[v._v("如果存在大量非私密的静态配置信息，可以保存到一个独立的 Git 仓库中，并进行版本控制。")])])]),v._v(" "),t("li",[v._v("动态配置\n"),t("ul",[t("li",[v._v("：程序在运行时可能多次读取，需要经常更新，甚至实时更新。")]),v._v(" "),t("li",[v._v("用传统的 Ansible 等脚本工具不方便管理，建议使用 Consul 等配置管理工具。")])])]),v._v(" "),t("li",[v._v("服务发现\n"),t("ul",[t("li",[v._v("：指程序需要获取某些服务的数量、地址。")]),v._v(" "),t("li",[v._v("可能属于静态配置，也可能属于动态配置。")])])])])])])]),v._v(" "),t("li",[v._v("构建产物\n"),t("ul",[t("li",[v._v("称为构件、工件，或者 artifact、component 。")]),v._v(" "),t("li",[v._v("应该根据文件格式，用各种仓库存储。例如 jar 包存储到 Nexus 服务器，Docker 镜像存储到 Harbor 服务器。")])])])]),v._v(" "),t("h2",{attrs:{id:"配置管理工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置管理工具"}},[v._v("#")]),v._v(" 配置管理工具")]),v._v(" "),t("p",[v._v("适合批量管理主机的工具：")]),v._v(" "),t("ul",[t("li",[v._v("Ansible\n"),t("ul",[t("li",[v._v("一个命令行工具。")]),v._v(" "),t("li",[v._v("采用 Python 开发，于 2012 年发布。")]),v._v(" "),t("li",[v._v("采用主从架构。以 SSH 方式控制远程主机，可以执行任意命令、传输文件。")])])]),v._v(" "),t("li",[v._v("Saltstack\n"),t("ul",[t("li",[v._v("一个命令行工具。")]),v._v(" "),t("li",[v._v("采用 Python 开发，于 2011 年发布。")]),v._v(" "),t("li",[v._v("采用 C/S 架构。需要在主控主机上运行 master 进程，在受控主机上运行 minion 进程。它们之间通过消息队列 ZeroMQ 进行通信。")])])]),v._v(" "),t("li",[v._v("Puppet\n"),t("ul",[t("li",[v._v("一个 Web 服务器。")]),v._v(" "),t("li",[v._v("采用 Ruby 开发，于 2005 年发布。")]),v._v(" "),t("li",[v._v("采用 C/S 架构、HTTP 通信。需要在主控主机上运行 master 进程，在受控主机上运行 agent 进程。")])])]),v._v(" "),t("li",[v._v("Chef\n"),t("ul",[t("li",[v._v("一个 Web 服务器。")]),v._v(" "),t("li",[v._v("采用 Ruby 开发，于 2009 年发布。")]),v._v(" "),t("li",[v._v("采用 C/S 架构、HTTP 通信。")])])])]),v._v(" "),t("p",[v._v("适合动态配置的工具：")]),v._v(" "),t("ul",[t("li",[v._v("confd\n"),t("ul",[t("li",[v._v("一个命令行工具，采用 Golang 开发，用于自动生成配置文件。")]),v._v(" "),t("li",[v._v("原理：从 zk、etcd、consul、redis 等后端轮询配置参数，根据 Golang 模板文件，渲染出配置文件。")])])]),v._v(" "),t("li",[v._v("Apollo\n"),t("ul",[t("li",[v._v("一个 Web 服务器。提供了丰富的配置管理功能，支持划分环境、版本回滚、安全审计。")]),v._v(" "),t("li",[v._v("由携程公司开源，采用 Java 开发。")])])])]),v._v(" "),t("p",[v._v("适合服务发现的工具：")]),v._v(" "),t("ul",[t("li",[v._v("Zookeeper")]),v._v(" "),t("li",[v._v("etcd")]),v._v(" "),t("li",[v._v("Consul")]),v._v(" "),t("li",[v._v("Nacos\n"),t("ul",[t("li",[v._v("一个 Web 服务器。支持配置管理、服务发现。")]),v._v(" "),t("li",[v._v("由阿里巴巴公司开源，采用 Java 开发。")])])]),v._v(" "),t("li",[v._v("Eureka ：由 Netflix 公司开源。")])]),v._v(" "),t("h2",{attrs:{id:"gitops"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gitops"}},[v._v("#")]),v._v(" GitOps")]),v._v(" "),t("p",[v._v("：一种配置文件的管理方案，于 2017 年提出。")]),v._v(" "),t("ul",[t("li",[v._v("特点：\n"),t("ul",[t("li",[v._v("将配置文件全部存储在 Git 仓库中，能够据此重新部署项目。")]),v._v(" "),t("li",[v._v("当用户修改 Git 仓库中的配置文件时，会自动触发 CI/CD 部署脚本。")])])]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("记录每次修改的版本，并可以回滚。")]),v._v(" "),t("li",[v._v("多个用户操作时，可以通过发出合并请求的方式，修改配置文件，实现流程审批。")])])])]),v._v(" "),t("h2",{attrs:{id:"microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#microservices"}},[v._v("#")]),v._v(" Microservices")]),v._v(" "),t("p",[v._v("：微服务，一种服务器架构，将业务系统从传统的大型服务器，划分成多个小型服务器，有利于模块化。")]),v._v(" "),t("ul",[t("li",[v._v("特点：\n"),t("ul",[t("li",[v._v("每个微服务独立部署，低耦合。")]),v._v(" "),t("li",[v._v("微服务之间通过 API 交互，可以采用不同的编程语言。")]),v._v(" "),t("li",[v._v("需要一个服务发现机制，让微服务之间能够连通。")]),v._v(" "),t("li",[v._v("Docker 技术流行之后，微服务变得容易实现。通常将每个微服务部署到一个 Docker 容器中。")])])]),v._v(" "),t("li",[v._v("常见的几种微服务框架：\n"),t("ul",[t("li",[v._v("Dubbo ：由阿里巴巴公司发布。微服务之间通过 RPC 协议进行通信，仅支持 Java 。")]),v._v(" "),t("li",[v._v("Spring Cloud ：微服务之间通过 RESTful API 进行通信，性能比 RPC 低。")])])])]),v._v(" "),t("h3",{attrs:{id:"service-mesh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-mesh"}},[v._v("#")]),v._v(" Service Mesh")]),v._v(" "),t("p",[v._v("：服务网格，是新一代的微服务技术，于 2016 年提出。")]),v._v(" "),t("ul",[t("li",[v._v("特点：\n"),t("ul",[t("li",[v._v("引入一个网络代理层，自动转发服务的流量，并进行服务发现、负载均衡。")]),v._v(" "),t("li",[v._v("属于透明代理，不需要服务编写代码来使用代理。")])])]),v._v(" "),t("li",[v._v("常见的几种框架：\n"),t("ul",[t("li",[v._v("Envoy")]),v._v(" "),t("li",[v._v("Linkerd")]),v._v(" "),t("li",[v._v("Istio\n"),t("ul",[t("li",[v._v("比 Linkerd 的功能更多。")]),v._v(" "),t("li",[v._v("在 k8s Pod 中加入一个 init 类型的容器，名为 istio-init 。负责设置 iptables 规则，将服务的出入流量转发到 Envoy 。")]),v._v(" "),t("li",[v._v("在 k8s Pod 中加入一个 sidecar 类型的容器，名为 istio-proxy 。负责运行 Envoy ，代理服务的流量。")])])]),v._v(" "),t("li",[v._v("Consul Connect")])])])])])}),[],!1,null,null,null);_.default=l.exports},703:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"分布式系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统"}},[v._v("#")]),v._v(" 分布式系统")]),v._v(" "),t("p",[v._v("：是指将一个软件系统的各个进程分别部署不同主机上。")]),v._v(" "),t("ul",[t("li",[v._v("小型的软件系统通常只部署在一台计算机上，属于集中式系统。而大型的软件系统通常部署成分布式系统，从而提高性能。")]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("便于横向增加系统节点，提高系统容量、性能，比如处理高并发流量。")]),v._v(" "),t("li",[v._v("可以将同一个应用运行多个实例，一个实例挂掉了就用其它实例，实现服务的高可用。")]),v._v(" "),t("li",[v._v("可以将一个数据存储多个副本，实现可靠的备份。")])])]),v._v(" "),t("li",[v._v("难点：\n"),t("ul",[t("li",[v._v("系统规模变大、结构变复杂，维护麻烦。")]),v._v(" "),t("li",[v._v("同一个应用要运行多个实例，占用资源的冗余多。")])])])]),v._v(" "),t("h2",{attrs:{id:"共识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共识"}},[v._v("#")]),v._v(" 共识")]),v._v(" "),t("p",[v._v("：Consensus ，指系统中不同节点作出的决策相同。")]),v._v(" "),t("ul",[t("li",[v._v("脑裂（brain split）\n"),t("ul",[t("li",[v._v("：指一个系统中存在多个有权决策的节点，并且作出了不同决策。")])])]),v._v(" "),t("li",[v._v("拜占庭将军问题（Byzantine Generals Problem）\n"),t("ul",[t("li",[v._v("：多个拜占庭将军自主观察敌情，然后通过投票决定进攻还是撤退。但可能存在不诚实的将军，或者投票信件被丢失、篡改。")]),v._v(" "),t("li",[v._v("该问题代表系统中某些节点传播虚假的信息，导致其它节点作出了错误决策。")])])])]),v._v(" "),t("h3",{attrs:{id:"paxos"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[v._v("#")]),v._v(" Paxos")]),v._v(" "),t("p",[v._v("：一个共识算法，于 1990 年发布。")]),v._v(" "),t("ul",[t("li",[v._v("系统中一些节点担任 Proposer ，有权发出提议（Proposal）、投票。\n"),t("ul",[t("li",[v._v("其它节点担任 Acceptor ，有权投票。")])])]),v._v(" "),t("li",[v._v("每个提议需要超过半数的节点投票同意，才能通过。\n"),t("ul",[t("li",[v._v("这属于多数派（Majority）策略，允许低于半数的节点不可用。")])])])]),v._v(" "),t("h3",{attrs:{id:"raft"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft"}},[v._v("#")]),v._v(" Raft")]),v._v(" "),t("p",[v._v("：一个共识算法，在 Paxos 算法的基础上作了改进。")]),v._v(" "),t("ul",[t("li",[v._v("系统中有且仅有一个节点担任 Leader ，有权发出提议（Proposal）、投票。\n"),t("ul",[t("li",[v._v("其它节点担任 Follower ，有权投票。")])])]),v._v(" "),t("li",[v._v("每次准备修改集群数据时，Leader 会将该提议发送给所有 Follower ，等超过半数的节点同意并执行之后，才通过该提议，从而达成共识、数据一致性。\n"),t("ul",[t("li",[v._v("超过半数，又称为达到法定成员数（Quorum）。\n"),t("ul",[t("li",[v._v("当节点总数为 N 时，法定成员数为 "),t("code",[v._v("Quorum = N/2 + 1")]),v._v(" ，其中 / 为整除运算符。")]),v._v(" "),t("li",[v._v("Quorum 必须超过半数。如果允许 Quorum 等于集群半数，甚至小于半数，则集群就可能同时存在不止一个 leader ，发生脑裂。")])])]),v._v(" "),t("li",[v._v("并不会等到所有节点都同意，因此属于最终一致性。")]),v._v(" "),t("li",[v._v("该共识是容错的，允许 Quorum 之外的节点不可用。\n"),t("ul",[t("li",[v._v("增加节点总数可以提供系统可用性，但是会增加每次达成共识的耗时。")])])])])]),v._v(" "),t("li",[v._v("Leader 定期发送心跳包给其它节点。如果心跳超时，则其它节点变为 Candidate 状态，选举一个节点担任新 Leader 。")]),v._v(" "),t("li",[v._v("每次选出 Leader ，就开始一个新任期，称为 Term 。")]),v._v(" "),t("li",[v._v("每个节点都信任其它节点发来的信息，因此不能实现拜占庭容错。")])]),v._v(" "),t("h3",{attrs:{id:"bully"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bully"}},[v._v("#")]),v._v(" Bully")]),v._v(" "),t("p",[v._v("：一个共识算法，与 Raft 算法相似。")]),v._v(" "),t("ul",[t("li",[v._v("如果 Leader 节点故障，则由 ID 最大的一个节点担任新 Leader 。")])]),v._v(" "),t("h3",{attrs:{id:"gossip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip"}},[v._v("#")]),v._v(" Gossip")]),v._v(" "),t("p",[v._v("：一个广播消息的协议，常用于 P2P 服务。")]),v._v(" "),t("ul",[t("li",[v._v("每个节点定期散播一次消息，最多发送给 k 个节点。\n"),t("ul",[t("li",[v._v("发送消息之后，不必确保对方接收。")]),v._v(" "),t("li",[v._v("其它节点收到消息之后，会散播给除了源节点之外的其它节点。")])])]),v._v(" "),t("li",[v._v("消息被病毒式传播，能实现最终一致性。")])]),v._v(" "),t("h3",{attrs:{id:"pow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pow"}},[v._v("#")]),v._v(" PoW")]),v._v(" "),t("p",[v._v("：工作量证明（Proof of Work），一个区块链的共识算法。")]),v._v(" "),t("ul",[t("li",[v._v("比特币采用基于哈希函数的 PoW 算法：\n"),t("ul",[t("li",[v._v("以区块为单位写入数据。")]),v._v(" "),t("li",[v._v("每个节点需要进行大量哈希运算，穷举猜测下一个区块的 nonce 随机数，第一个猜出来的节点有权生成该区块，然后广播给其它节点。")])])]),v._v(" "),t("li",[v._v("可实现顺序一致性，并实现拜占庭容错。")])]),v._v(" "),t("h3",{attrs:{id:"pos"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pos"}},[v._v("#")]),v._v(" PoS")]),v._v(" "),t("p",[v._v("：权益证明（Proof of Stake），一个区块链的共识算法。")]),v._v(" "),t("ul",[t("li",[v._v("每个节点拥有的代币越多，则权益越大，有更大概率获得下一个区块的打包权。")]),v._v(" "),t("li",[v._v("与 PoW 相比，节省了运算成本。")])]),v._v(" "),t("h2",{attrs:{id:"一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[v._v("#")]),v._v(" 一致性")]),v._v(" "),t("p",[v._v("：Consistency ，指系统中不同节点拥有的数据副本一致（通常还应该是最新的数据）。")]),v._v(" "),t("ul",[t("li",[v._v("数据库的 ACID 指的是事务的一致性，而分布式系统中主要研究数据的一致性。")]),v._v(" "),t("li",[v._v("通常，需要各节点先达成共识，才能实现数据一致性。\n"),t("ul",[t("li",[v._v("不过数据不一致性时，各节点可能因为不同的数据副本而作出不同的决策，不容易达成共识。")])])]),v._v(" "),t("li",[v._v("每个写操作之后，如果等所有节点复制完新数据，才开始下一个读操作，则称为同步复制，否则称为异步复制。")]),v._v(" "),t("li",[v._v("常见的几种一致性模型：\n"),t("ul",[t("li",[v._v("强一致性：采用同步复制，保证各节点的一致性。\n"),t("ul",[t("li",[v._v("严格一致性（Strict consistency）\n"),t("ul",[t("li",[v._v("：每个写操作之后，各节点会立即变为一致，即实时复制。比如将写操作复制到各节点上同时执行。")])])]),v._v(" "),t("li",[v._v("顺序一致性（Sequential consistency）\n"),t("ul",[t("li",[v._v("：当程序发出多个读写操作时，各节点会按相同顺序执行这些操作。因此某些节点可能因为执行慢而数据滞后，但顺序并不会出错。")])])]),v._v(" "),t("li",[v._v("线性一致性\n"),t("ul",[t("li",[v._v("：具有实时性的顺序一致性，各节点同时遵守相同顺序。每个写操作在所有节点都生效之后，才会开始下一个操作。")]),v._v(" "),t("li",[v._v("又称为可线性化（Linearizability）、原子一致性。")]),v._v(" "),t("li",[v._v("强弱程度：严格一致性 > 线性一致性 > 顺序一致性")])])])])]),v._v(" "),t("li",[v._v("弱一致性：采用异步复制，因此各节点可能不一致。\n"),t("ul",[t("li",[v._v("因果一致性（Causal consistency）\n"),t("ul",[t("li",[v._v("：具有因果关系的多个操作（比如读写同一个数据），才保证顺序一致性，而其它并发操作则不限制。")])])]),v._v(" "),t("li",[v._v("最终一致性（Eventual consistency）\n"),t("ul",[t("li",[v._v("：允许各节点暂时不一致，但保证在一定时间内实现一致。")])])])])])])])]),v._v(" "),t("h2",{attrs:{id:"可用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可用性"}},[v._v("#")]),v._v(" 可用性")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("服务可用（Available）")]),v._v(" "),t("ul",[t("li",[v._v("：指客户端发出请求时，能收到正常的响应。\n"),t("ul",[t("li",[v._v("响应时长不能超过正常范围。")]),v._v(" "),t("li",[v._v("响应的内容不能是错误的，但可以不是最新的数据。")])])]),v._v(" "),t("li",[v._v("服务不可用时，又称为服务中断、故障。")])])]),v._v(" "),t("li",[t("p",[v._v("可用性（Availability）")]),v._v(" "),t("ul",[t("li",[v._v("：又称为可用率。如果服务可用的时长，占提供服务的总时长的比例接近 100% ，则称为可用性高，否则称为可用性低。")]),v._v(" "),t("li",[v._v("采用负载均衡、健康检查等措施可以实现服务的高可用性（High Availability，HA）。")])])]),v._v(" "),t("li",[t("p",[v._v("SLA （Service Level Agreement ，服务等级协议）")]),v._v(" "),t("ul",[t("li",[v._v("：由服务提供商承诺的服务质量指标，如果未达到则给客户一定赔偿。")]),v._v(" "),t("li",[v._v("比如承诺服务的全年可用性为 99% ，即不可用的时长低于 3.65 天；全年可用性为 99.9% ，即不可用时长低于 0.365*24=8.76 小时。")])])]),v._v(" "),t("li",[t("p",[v._v("提高系统性能的常见方案：")]),v._v(" "),t("ul",[t("li",[v._v("垂直扩展：增加单个服务的性能，比如增加服务器的 CPU 、内存等资源。")]),v._v(" "),t("li",[v._v("水平扩展：增加服务实例的数量，比如在一组服务器上分别部署一个服务实例。")])])])]),v._v(" "),t("h3",{attrs:{id:"常见问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[v._v("#")]),v._v(" 常见问题")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("单点故障（Single Point of Failure）")]),v._v(" "),t("ul",[t("li",[v._v("：单个模块不可用，导致整个服务不可用。或者单个服务不可用，导致整个系统不可用。")])])]),v._v(" "),t("li",[t("p",[v._v("级联故障（Cascading failure）")]),v._v(" "),t("ul",[t("li",[v._v("：上游服务故障，导致下游调用它的服务故障。")])])]),v._v(" "),t("li",[t("p",[v._v("服务雪崩")]),v._v(" "),t("ul",[t("li",[v._v("：级联故障导致大量服务不可用。")])])])]),v._v(" "),t("h3",{attrs:{id:"常见措施"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见措施"}},[v._v("#")]),v._v(" 常见措施")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("服务熔断")]),v._v(" "),t("ul",[t("li",[v._v("：当上游服务可用性降低时，下游服务停止调用它，避免级联故障。")]),v._v(" "),t("li",[v._v("服务熔断之后，下游服务可以拒绝提供服务，也可以开始服务降级。")])])]),v._v(" "),t("li",[t("p",[v._v("服务降级")]),v._v(" "),t("ul",[t("li",[v._v("：降低给客户端的响应质量，从而降低服务器的负载。")]),v._v(" "),t("li",[v._v("例如停止次要功能、延时处理请求、减少响应内容、使用旧的响应内容，甚至拒绝服务。")]),v._v(" "),t("li",[v._v("可以在配置平台增加一个参数开关，启用它则开始服务降级。")])])]),v._v(" "),t("li",[t("p",[v._v("服务限流")]),v._v(" "),t("ul",[t("li",[v._v("：属于服务降级，指服务限制一定时间内处理的请求数量，拒绝超过限制的请求，避免因为负载过大而故障。")])])])]),v._v(" "),t("h4",{attrs:{id:"健康检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#健康检查"}},[v._v("#")]),v._v(" 健康检查")]),v._v(" "),t("p",[v._v("：Health Check ，通过软件检查集群中各个服务器的状态，自动发现故障的服务器。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("发现故障节点之后，需要及时将它下线，避免客户端访问它而服务不可用。或者通过重启等方式修复。")])]),v._v(" "),t("li",[t("p",[v._v("keepalived ：一个命令行工具，用于对多个服务器进行健康检查，自动去除故障服务器。")]),v._v(" "),t("ul",[t("li",[v._v("在集群的每个服务器上部署一份，相互之间通过 VRRP（Virtual Router Redundancy Protocol ，虚拟路由冗余协议）通信，实现路由的高可用。")]),v._v(" "),t("li",[v._v("工作在第三层时，是基于 ICMP 协议检查服务器是否在线。")]),v._v(" "),t("li",[v._v("工作在第四层时，是基于 TCP 协议检查服务器的端口是否开通。")]),v._v(" "),t("li",[v._v("工作在第七层时，是基于 HTTP 协议检查服务器是否正常工作。")])])])]),v._v(" "),t("h4",{attrs:{id:"负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),t("p",[v._v("：Load Balance ，将服务器部署多个实例，用一个反向代理服务器接收所有客户端的访问流量，然后按特定的策略分发给各个实例。")]),v._v(" "),t("ul",[t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("容易横向扩容。")]),v._v(" "),t("li",[v._v("均衡各个服务器的负载压力，降低单点故障的风险。")]),v._v(" "),t("li",[v._v("有的负载均衡服务器能对各个服务器进行健康检查，避免将流量转发给故障的服务器，从而避免单点故障。")])])])]),v._v(" "),t("h2",{attrs:{id:"分区容错性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分区容错性"}},[v._v("#")]),v._v(" 分区容错性")]),v._v(" "),t("p",[v._v("：Partition tolerance ，指系统出现网络分区时，能否继续提供服务。")]),v._v(" "),t("ul",[t("li",[v._v("如果任意两个节点之间不能在指定时间内将数据同步一致（比如网络延迟较大、节点故障），则视作网络中断，出现了网络分区。")])]),v._v(" "),t("h2",{attrs:{id:"cap-定理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cap-定理"}},[v._v("#")]),v._v(" CAP 定理")]),v._v(" "),t("p",[v._v("：一个流行的理论，认为在分布式系统中，一致性（C）、可用性（A）、分区容错性（P） 三种性能通常不能同时满足，最多满足两种。")]),v._v(" "),t("ul",[t("li",[v._v("假设分布式系统中存在两个节点 N1、N2 ，两者的网络通信必然存在一定延迟。先在 N1 处写入数据 D ，然后在 N2 处读取数据 D 。此时：\n"),t("ul",[t("li",[v._v("如果 N2 等同步 N1 的数据之后再返回响应，则满足了 C ，但不满足 A 。")]),v._v(" "),t("li",[v._v("如果 N2 不同步 N1 的数据就返回响应，则必然是错误的响应，满足了 A ，但不满足 C 。")]),v._v(" "),t("li",[v._v("如果 N1 或 N2 因为网络分区而不能提供服务，则满足了 C ，但不满足 A、P 。")])])])])])}),[],!1,null,null,null);_.default=l.exports},713:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"存储类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储类型"}},[v._v("#")]),v._v(" 存储类型")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("块存储")]),v._v(" "),t("ul",[t("li",[v._v("：不管数据内容，只管提供一定容量的存储空间。")]),v._v(" "),t("li",[v._v("比如硬盘等块设备。")])])]),v._v(" "),t("li",[t("p",[v._v("文件存储")]),v._v(" "),t("ul",[t("li",[v._v("：按目录树存储文件，每个文件通过唯一的路径寻址。")]),v._v(" "),t("li",[v._v("主要用于存储非结构化数据，比如视频、图片，而结构化数据通常用数据库存储。")]),v._v(" "),t("li",[v._v("比如 FTP、HTTP、NFS 等服务器。")])])]),v._v(" "),t("li",[t("p",[v._v("对象存储")]),v._v(" "),t("ul",[t("li",[v._v("：将文件以 key-value 形式存储。\n"),t("ul",[t("li",[v._v("用文件名作为 key ，不使用目录树，这样可以避免路径寻址的耗时。")]),v._v(" "),t("li",[v._v("用文件内容作为 value ，且分成多个部分存储，这样可以通过并行读写提高访问速度，但不支持修改文件。")])])]),v._v(" "),t("li",[v._v("Amazon S3（Simple Storage Service）是目前最流行的对象存储协议，用户可通过 RESTful API 或 aws 命令进行访。")]),v._v(" "),t("li",[v._v("对象存储是新一代的存储方案，介于块存储与文件存储之间，优点较多，但成本也较高。")])])])]),v._v(" "),t("h2",{attrs:{id:"相关软件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关软件"}},[v._v("#")]),v._v(" 相关软件")]),v._v(" "),t("ul",[t("li",[v._v("Ceph ：同时支持块存储、文件存储、对象存储。")]),v._v(" "),t("li",[v._v("GlusterFS ：用于文件存储。2011 年被红帽公司收购。")]),v._v(" "),t("li",[v._v("GoogleFS ：用于文件存储。由 Google 开发，闭源。")]),v._v(" "),t("li",[v._v("HDFS ：用于文件存储，借鉴了 GoogleFS 。")]),v._v(" "),t("li",[v._v("FastDFS ：用于文件存储。")]),v._v(" "),t("li",[v._v("Swift ：用于对象存储。")]),v._v(" "),t("li",[v._v("MinIO ：用于对象存储。")])]),v._v(" "),t("h3",{attrs:{id:"nfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nfs"}},[v._v("#")]),v._v(" NFS")]),v._v(" "),t("p",[v._v("：网络文件系统（Network File System），一个用于共享文件系统的网络协议，工作在表示层。")]),v._v(" "),t("ul",[t("li",[v._v("1984 年由 Sun 公司发布。")]),v._v(" "),t("li",[v._v("采用 C/S 架构。\n"),t("ul",[t("li",[v._v("客户端需要通过 RPC 协议访问服务器的 UDP 111 端口，查询到 NFS 各项服务进程当前监听的端口，然后与其建立 TCP 连接。")]),v._v(" "),t("li",[v._v("客户端可以挂载服务器上共享的文件系统，直接读写其中的文件，像读写本机文件一样方便。")])])])]),v._v(" "),t("h3",{attrs:{id:"iscsi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iscsi"}},[v._v("#")]),v._v(" iSCSI")]),v._v(" "),t("p",[v._v("：因特网小型计算机系统接口（Internet Small Computer System Interface），一个用于共享存储设备的网络协议。")]),v._v(" "),t("ul",[t("li",[v._v("2003 年由 IBM 公司发布。")]),v._v(" "),t("li",[v._v("采用 C/S 架构，基于 TCP/IP 协议通信。")]),v._v(" "),t("li",[v._v("比 NFS 更底层，可以将远程主机的存储设备（比如磁盘）挂载到本机。\n"),t("ul",[t("li",[v._v("原理：将本机发出的 SCSI 命令，传输到远程主机上执行。")])])])])])}),[],!1,null,null,null);_.default=l.exports},719:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),t("p",[v._v("：（Message Queue ，MQ），一种用于程序之间通信的中间件，可以暂存消息。先由发送方将消息放入消息队列，再由接收方从中获取消息。")]),v._v(" "),t("ul",[t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("解耦    ：每个程序只需要考虑对 MQ 的访问，不必直接与其它程序通信，因此耦合度低。")]),v._v(" "),t("li",[v._v("异步    ：消息的发送方和接收方异步工作，避免了等待对方回复的时间。")]),v._v(" "),t("li",[v._v("削峰    ：即使发送方突然发出了大量消息，接收方也依然是按照自己的速度从 MQ 获取消息，因此可以削弱消息数量的峰值。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("增加了系统的规模，需要多考虑一个中间件。")]),v._v(" "),t("li",[v._v("需要考虑一致性问题，保证消息不会被重复发布、消费。")]),v._v(" "),t("li",[v._v("需要考虑收发消息的顺序。")])])]),v._v(" "),t("li",[v._v("提供 MQ 服务的软件有多种，大多借鉴了 JMS 规范。")])]),v._v(" "),t("p",[v._v("使用消息队列的主要难点：")]),v._v(" "),t("ul",[t("li",[v._v("如何保证消息不被重复消费\n"),t("ul",[t("li",[v._v("可以给每个消息分配一个唯一 ID ，客户端记录自己获得的所有消息 ID ，如果收到重复的消息就忽略。或者服务器记录每个客户端获得的所有消息 ID ，不发送重复的消息。")])])]),v._v(" "),t("li",[v._v("如何保证不丢失消息\n"),t("ul",[t("li",[v._v("可能原因：客户端发布或接收消息时丢失、消息队列存储消息时丢失。")])])])]),v._v(" "),t("h2",{attrs:{id:"jms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jms"}},[v._v("#")]),v._v(" JMS")]),v._v(" "),t("p",[v._v("JMS（Java Message Service ，Java 消息服务）：Java 平台上消息中间件的 API 规范。")]),v._v(" "),t("p",[v._v("基本概念：")]),v._v(" "),t("ul",[t("li",[v._v("客户端          ：连接到 MQ 服务器的程序，可以作为消息的发送方（Sender）或接收方（Receiver）。")]),v._v(" "),t("li",[v._v("消息            ：程序之间的通信内容。")])]),v._v(" "),t("p",[v._v("JMS 定义了两种传输消息的模式：")]),v._v(" "),t("ul",[t("li",[v._v("点对点模式（Point to Point ，P2P）：一条消息只能被一个客户端接收。\n"),t("ul",[t("li",[v._v("消息的发送方、接收方分别称为生产者（Producer）、消费者（Consumer）。")]),v._v(" "),t("li",[v._v("Producer 将消息发送到某个队列（Queue）中，而消费者到某个 Queue 中获取消息（该过程称为消费）。")]),v._v(" "),t("li",[v._v("队列会长时间保存消息，直到它被消费或超时。")])])]),v._v(" "),t("li",[v._v("发布/订阅模式（Pub/Sub)：一条消息可以被多个客户端接收。\n"),t("ul",[t("li",[v._v("消息的发送方、接收方分别称为发布者（Publisher）、订阅者（Subscriber）。")]),v._v(" "),t("li",[v._v("Publisher 将消息发布到某个主题（Topic）下，而 MQ 会立即将该消息推送给订阅该 Topic 的所有 Subscriber 。")]),v._v(" "),t("li",[v._v("一个 Subscriber 可以订阅任意个 Topic ，但是只会收到订阅之后新发布的消息，不会收到历史消息，因为 MQ 不会长时间保存消息。")])])])]),v._v(" "),t("h2",{attrs:{id:"常见的消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的消息队列"}},[v._v("#")]),v._v(" 常见的消息队列")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("ActiveMQ")])]),v._v(" "),t("li",[t("p",[v._v("RabbitMQ")]),v._v(" "),t("ul",[t("li",[v._v("采用 erlang 开发，实现了高级消息队列（Advanced Message Queuing Protocol ，AMQP）协议。")]),v._v(" "),t("li",[v._v("并发能力强，延迟很低。")]),v._v(" "),t("li",[v._v("生产者发送的消息，会由 exchange（交换机）转发到某个或某些队列。")])])]),v._v(" "),t("li",[t("p",[v._v("RocketMQ")]),v._v(" "),t("ul",[t("li",[v._v("采用 Java 开发，由阿里巴巴公司开源，捐献给了 ASF 。")]),v._v(" "),t("li",[v._v("它借鉴了 Kafka ，但功能更强。")])])]),v._v(" "),t("li",[t("p",[v._v("Kafka")])])])])}),[],!1,null,null,null);_.default=l.exports},734:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"测试工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试工具"}},[v._v("#")]),v._v(" 测试工具")]),v._v(" "),t("p",[v._v("根据行为的不同，可以将 Linux 的测试工具分为两类：")]),v._v(" "),t("ul",[t("li",[v._v("检查工具：检查系统的静态信息或动态信息。\n"),t("ul",[t("li",[v._v("系统的静态信息：比如磁盘容量、网卡带宽，一般只需查看一次。")]),v._v(" "),t("li",[v._v("系统的动态信息：比如磁盘读写速度、网卡收发速度，表示系统的运行状态，可能需要每秒检查一次。")])])]),v._v(" "),t("li",[v._v("测试工具：主动实施某种行为来测试系统。\n"),t("ul",[t("li",[v._v("比如模拟大量的网络请求，从而测试网络性能。")]),v._v(" "),t("li",[v._v("测试工具一般会运行一段时间，然后显示测试结果。也可以在运行测试工具时，用其它工具检查系统的动态信息。")])])])]),v._v(" "),t("h2",{attrs:{id:"测试思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试思路"}},[v._v("#")]),v._v(" 测试思路")]),v._v(" "),t("p",[v._v("先用 top、vmstat、sar 等命令检查系统的宏观状态，再用其它工具检查系统的细节指标。")]),v._v(" "),t("ul",[t("li",[v._v("主要看性能指标的最大值、稳定性。")]),v._v(" "),t("li",[v._v("如果发现系统某方面异常，分析是某个进程导致的还是系统本身的问题。")]),v._v(" "),t("li",[v._v("除了使用测试工具，还要检查各种日志。")])]),v._v(" "),t("p",[v._v("常见的测试项：")]),v._v(" "),t("ul",[t("li",[v._v("CPU\n"),t("ul",[t("li",[v._v("空闲 CPU 是否足够、平均负载是否很大")])])]),v._v(" "),t("li",[v._v("进程\n"),t("ul",[t("li",[v._v("是否有僵尸进程。")])])]),v._v(" "),t("li",[v._v("内存\n"),t("ul",[t("li",[v._v("可用内存是否足够、是否使用了 swap 。")])])]),v._v(" "),t("li",[v._v("磁盘\n"),t("ul",[t("li",[v._v("CPU 的 iowait 百分比是否一直很大、磁盘 IO 速度、iowait 时长")])])]),v._v(" "),t("li",[v._v("网络\n"),t("ul",[t("li",[v._v("用 ping 测试与某个主机的网络是否连通（前提是对方启用了 ICMP 协议）。")]),v._v(" "),t("li",[v._v("用 telnet 测试能否访问到某个主机的某个端口。")]),v._v(" "),t("li",[v._v("用 curl 测试能否访问到某个 HTTP 服务器。")]),v._v(" "),t("li",[v._v("用 sar -n DEV 查看本机网络端口的收发速率。")]),v._v(" "),t("li",[v._v("用 iperf 测试 TCP、UDP 的带宽。")]),v._v(" "),t("li",[v._v("用 ab、wrk、Jmeter 进行 HTTP 压测。")])])])]),v._v(" "),t("h2",{attrs:{id:"性能指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能指标"}},[v._v("#")]),v._v(" 性能指标")]),v._v(" "),t("h3",{attrs:{id:"业务服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#业务服务"}},[v._v("#")]),v._v(" 业务服务")]),v._v(" "),t("ul",[t("li",[v._v("QPS ：每秒完成的查询数（Queries Per Second）")]),v._v(" "),t("li",[v._v("TPS ：每秒完成的事务数（Transactions Per Second）\n"),t("ul",[t("li",[v._v("例如用户向 Web 服务器发出一个请求，服务器后端可能查询多次，才返回响应结果给用户，但整个过程只算一个事务。")])])]),v._v(" "),t("li",[v._v("并发数")]),v._v(" "),t("li",[v._v("QoS （Quality of Service ，服务质量）\n"),t("ul",[t("li",[v._v("衡量服务质量的好坏时，需要综合考虑成功率、响应速度、并发量等指标。")]),v._v(" "),t("li",[v._v("比如通信线路的 QoS 越低，越有可能在通信过程中丢失数据包或出错。")])])])]),v._v(" "),t("h3",{attrs:{id:"tcp-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp"}},[v._v("#")]),v._v(" TCP/UDP")]),v._v(" "),t("ul",[t("li",[v._v("接收速度、发送速度\n"),t("ul",[t("li",[v._v("带宽    ：网络的实际最大传输速率，由网卡和实际网络链路决定。（每个网卡的产品信息中还有一个理论带宽）")]),v._v(" "),t("li",[v._v("吞吐量  ：没有丢包时的最大传输速率。吞吐量/带宽就是该网络链路的实际使用率。")])])]),v._v(" "),t("li",[v._v("接收包速、发送包速\n"),t("ul",[t("li",[v._v("pps ：每秒收发的数据包数（packet per second），一般是指 TCP/UDP 包。\npps 主要受到网络带宽、从网卡到 CPU 收发网络包的速度影响。\n采用最小的以太网帧（64 Bytes）、UDP 包（因为无需连接），可以测试出一个主机的最大收发 pps 。")]),v._v(" "),t("li",[v._v("丢包率")]),v._v(" "),t("li",[v._v("重传率：重新传输的数据包的百分比。")])])]),v._v(" "),t("li",[v._v("通信延迟：指建立 TCP 连接的耗时，或一个数据包往返的耗时。")]),v._v(" "),t("li",[v._v("并发连接数")])])])}),[],!1,null,null,null);_.default=l.exports},769:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"网络协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络协议"}},[v._v("#")]),v._v(" 网络协议")]),v._v(" "),t("ul",[t("li",[v._v("网络协议泛指计算机之间进行通信时需要遵守的规则。")]),v._v(" "),t("li",[v._v("网络协议有很多种，用途也不同。例如：网络层的 ARP 协议常用于主机寻址，应用层的 HTTP 协议常用于 Web 服务。")])]),v._v(" "),t("h2",{attrs:{id:"服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器"}},[v._v("#")]),v._v(" 服务器")]),v._v(" "),t("p",[v._v("：指网络中的某些主机，可以为其它主机提供某种服务。")]),v._v(" "),t("ul",[t("li",[v._v("服务器通常要保持运行，以持续提供服务。")]),v._v(" "),t("li",[v._v("不同用途的服务器通常采用不同的通信协议，比如采用 FTP 协议时，称为 FTP 服务器。")])]),v._v(" "),t("p",[v._v("服务器常见的几种工作模式：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("客户端/服务器模式（Client/Server ，C/S）")]),v._v(" "),t("ul",[t("li",[v._v("运行一个或多个主机作为服务器，再运行一个或多个主机作为客户端。")]),v._v(" "),t("li",[v._v("客户端连接到服务器之后，便可以享受其提供的服务、功能。")])])]),v._v(" "),t("li",[t("p",[v._v("浏览器/服务器模式（Browser/Server ，B/S）")]),v._v(" "),t("ul",[t("li",[v._v("属于 C/S 模式。使用特制的浏览器软件作为客户端，例如 Web 浏览器。")])])]),v._v(" "),t("li",[t("p",[v._v("点对点（Peer to Peer ，P2P）")]),v._v(" "),t("ul",[t("li",[v._v("两个主机之间通信时身份对等，有相同的能力，而不区分服务器、客户端。")]),v._v(" "),t("li",[v._v("大量 P2P 主机可组成 P2P 网络。与 C/S 网络相比，没有主机专门担任服务器，去中心化。")]),v._v(" "),t("li",[v._v("线上到线下（Online to Offline ，O2O）的名字与 P2P 相似，但概念不同。")])])])]),v._v(" "),t("h2",{attrs:{id:"arp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arp"}},[v._v("#")]),v._v(" ARP")]),v._v(" "),t("p",[v._v("：地址解析协议（Address Resolution Protocol），可以根据主机的 IP 地址查询到它的 MAC 地址，常用于局域网的主机寻址。")]),v._v(" "),t("ul",[t("li",[v._v("属于网络层协议。")])]),v._v(" "),t("h2",{attrs:{id:"icmp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#icmp"}},[v._v("#")]),v._v(" ICMP")]),v._v(" "),t("p",[v._v("：因特网控制报文协议（Internet Control Messages Protocol），用于测试网络是否连通、网络延迟。")]),v._v(" "),t("ul",[t("li",[v._v("属于网络层协议，是 IP 协议的一部分，基于 IP 协议寻址。")]),v._v(" "),t("li",[v._v("原理：\n"),t("ul",[t("li",[v._v("向目标主机发送一个 ICMP 报文，根据收到回复的时间间隔就可以知道通信延迟。\n"),t("ul",[t("li",[v._v("ICMP 报文的头部用 1 个字节记录了该报文的生存期（Time To Live ，TTL）。")]),v._v(" "),t("li",[v._v("ICMP 报文每经过一跳路由器，TTL 的值就会被减一，当 TTL 为零时路由器就会丢弃该报文。")])])]),v._v(" "),t("li",[v._v("如果没收到回复，则原因可能是：\n"),t("ul",[t("li",[v._v("网络不连通")]),v._v(" "),t("li",[v._v("目标主机不允许 ICMP 通信")])])])])])]),v._v(" "),t("h2",{attrs:{id:"dhcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dhcp"}},[v._v("#")]),v._v(" DHCP")]),v._v(" "),t("p",[v._v("：动态主机配置协议，用于给一些主机动态分配 IP 地址，广泛应用于企业单位的局域网中。")]),v._v(" "),t("ul",[t("li",[v._v("属于应用层协议，基于 UDP 通信。")]),v._v(" "),t("li",[v._v("IP 地址的分配方法分为静态和动态两种。手动配置主机的 IP 就属于静态分配。")]),v._v(" "),t("li",[v._v("客户端使用 DHCP 服务的过程分为以下四步：（此时客户端与服务器通过 UDP 协议通信，一般使用受限广播报文）\n"),t("ul",[t("li",[v._v("Request ：客户端广播“DHCP discover”报文。")]),v._v(" "),t("li",[v._v("Reply ：服务器收到 discover 报文后会广播“DHCP offer”报文，包括准备分配的 IP 地址、默认网关等信息。")]),v._v(" "),t("li",[v._v("Request ：客户端收到 offer 报文后就广播“DHCP request”报文，表示请求使用这个 IP 地址。")]),v._v(" "),t("li",[v._v("Reply ：服务器收到 request 报文后就广播“DHCP ack”报文即确认报文，将 IP 地址分配给客户端。")])])]),v._v(" "),t("li",[v._v("DHCP 服务器的主要配置内容：\n"),t("ul",[t("li",[v._v("作用域：指 DHCP 服务器所管理的 IP 地址的范围，通常为一个连续网段。")]),v._v(" "),t("li",[v._v("排除范围：指作用域内一些不被 DHCP 服务器分配的 IP 地址。")]),v._v(" "),t("li",[v._v("地址池：作用域内排除掉不分配的 IP 地址，剩下的就是地址池。")]),v._v(" "),t("li",[v._v("租约：客户端只能租用 IP 地址一段时间。")])])])]),v._v(" "),t("h2",{attrs:{id:"nat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nat"}},[v._v("#")]),v._v(" NAT")]),v._v(" "),t("p",[v._v("：网络地址转换（Network Address Translation）")]),v._v(" "),t("ul",[t("li",[v._v("工作原理：\n"),t("ul",[t("li",[v._v("DNAT（Destination NAT）：当 NAT 网关收到公网发来的 IP 包时，将 IP 包中的目的 IP 从公网 IP 转换成私网 IP ，然后转发给对应的私网主机。")]),v._v(" "),t("li",[v._v("SNAT（Source NAT）：当 NAT 网关收到私网主机向公网发送的 IP 包时，将 IP 包中的源 IP 地址从私网 IP 转换成公网 IP ，然后转发到公网。")])])]),v._v(" "),t("li",[v._v("NAT 网关一般是一台服务器，工作在网络层（与 proxy 不同）。\n"),t("ul",[t("li",[v._v("NAT 网关内至少有两张网卡，分别连接私网和公网。")]),v._v(" "),t("li",[v._v("NAT 网关一般给私网内的主机分配 10.0.0.0、172.16.0.0、192.168.0.0 三种范围的专有网络地址，并保存一些可用的公网 IP 地址。")]),v._v(" "),t("li",[v._v("NAT 网关上维护了一张 NAT 表，记录了每个私网 IP 与公网 IP 的转换关系。如果经过 NAT 网关的 IP 包中的 IP 地址不在 NAT 表中，就丢弃该报文。")])])]),v._v(" "),t("li",[v._v("NAT 网关的分类：\n"),t("ul",[t("li",[v._v("静态 NAT(Static NAT)：NAT 表事先写好，不再变化。这样可以直接实现 DNAT 。")]),v._v(" "),t("li",[v._v("动态地址 NAT(Pooled NAT)：NAT 表可以动态变化。这样不能实现 DNAT 。")]),v._v(" "),t("li",[v._v("端口多路复用（Port Address Translation ，PAT）：所有私网主机共用一个外网 IP ，只是连接到 NAT 网关的不同端口上。NAT 网关与公网通信时，使用的不同端口号代表了不同的私网主机，转换 IP 包中的 IP 地址和端口号。")])])])])])}),[],!1,null,null,null);_.default=l.exports},772:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"网络接口卡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络接口卡"}},[v._v("#")]),v._v(" 网络接口卡")]),v._v(" "),t("p",[v._v("：Network Interface Card（NIC），又称为网卡、网络适配器。")]),v._v(" "),t("ul",[t("li",[v._v("工作在物理层，以及数据链路层的 MAC 子层。")]),v._v(" "),t("li",[v._v("网卡将计算机与传输介质相连从而接入网络，是网络中最基本的设备。")]),v._v(" "),t("li",[v._v("每个网卡都有一个在世界上唯一的 MAC 地址（又称为物理地址、硬件地址），用于在数据链路层表示自己的身份。\n"),t("ul",[t("li",[v._v("MAC 地址长度为 48 位，用 12 个十六进制数表示。如 00-e0-4c-46-56-3f ，也可写作 00e0.4c46.563f 。")]),v._v(" "),t("li",[v._v("根据地址解析协议（ARP）可以由 IP 地址得到对应的 MAC 地址，根据反向地址解析协议（RARP）可以由 MAC 地址得到对应的 IP 地址。")])])])]),v._v(" "),t("h2",{attrs:{id:"无线接入点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无线接入点"}},[v._v("#")]),v._v(" 无线接入点")]),v._v(" "),t("p",[v._v("：Access Point（AP），又称为无线 AP、热点，相当于无线集线器。")]),v._v(" "),t("ul",[t("li",[v._v("除了只能连接结点的简单型无线 AP ，还有能提供路由功能的扩展型无线 AP（目前更常见）。")]),v._v(" "),t("li",[v._v("无线 AP 是无线局域网的核心设备。")])]),v._v(" "),t("h2",{attrs:{id:"中继器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中继器"}},[v._v("#")]),v._v(" 中继器")]),v._v(" "),t("p",[v._v("：Repeater ，将衰减或变形的信号进行放大整形，从而延长信号的传输距离。")]),v._v(" "),t("ul",[t("li",[v._v("工作在物理层。")]),v._v(" "),t("li",[v._v("中继器连接的两个网段仍然属于同一个网络，所以中继器不是网络互联设备。")])]),v._v(" "),t("h2",{attrs:{id:"网桥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网桥"}},[v._v("#")]),v._v(" 网桥")]),v._v(" "),t("p",[v._v("：Bridge")]),v._v(" "),t("ul",[t("li",[v._v("工作在数据链路层的 MAC 子层。")]),v._v(" "),t("li",[v._v("可以通过转发数据帧将两个数据链路层协议不同（但上层协议相同）、传输介质不同、传输速率不同的网络在 MAC 子层连接起来。")]),v._v(" "),t("li",[v._v("基本职责：通过自学习的方法自动地建立和维护一个表示目的地址 MAC 与端口对应关系的 MAC 地址表。")]),v._v(" "),t("li",[v._v("网桥的不同端口的信道相互独立，所以可以将局域网分成多个冲突域独立的子网。\n"),t("ul",[t("li",[v._v("但是网桥不能隔离广播风暴，而且端口少，只适用于小型局域网。")]),v._v(" "),t("li",[v._v("目前网桥已经被同样可以隔离冲突域并且端口更多的交换机取代。")])])]),v._v(" "),t("li",[v._v("透明网桥是目前最常见的一种网桥。\n"),t("ul",[t("li",[v._v("透明是指网桥对局域网没有影响、不可见，相当于透明。")])])]),v._v(" "),t("li",[v._v("网络互联时可能产生回路，即出现环型拓扑结构，为了避免回路中网桥重复转发同一数据帧，可以采用生成树协议（Spanning Tree Protocol ，STP）。\n"),t("ul",[t("li",[v._v("生成树算法会选择网络中的一个网桥作为根，其它网桥各自选出自身到根网桥最近的一个端口作为转发端口，并暂时阻塞其它端口，从而构成一个树型拓扑结构的网络。这样既能消除回路，又能保留备用路径即冗余。")])])])]),v._v(" "),t("h2",{attrs:{id:"网关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网关"}},[v._v("#")]),v._v(" 网关")]),v._v(" "),t("p",[v._v("：Gateway ，泛指两个网络相连的关口。")]),v._v(" "),t("ul",[t("li",[v._v("通常用一个路由器作为网关。")])]),v._v(" "),t("h2",{attrs:{id:"集线器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集线器"}},[v._v("#")]),v._v(" 集线器")]),v._v(" "),t("p",[v._v("：Hub ，是共享式局域网的核心设备。")]),v._v(" "),t("ul",[t("li",[v._v("工作在物理层。")]),v._v(" "),t("li",[v._v("多个结点连接到集线器会构成物理上的星型结构，但逻辑上仍然是总线型结构。")]),v._v(" "),t("li",[v._v("背板是集线器中传输数据的物理通道，集线器的各个结点共享背板的带宽。")]),v._v(" "),t("li",[v._v("普通集线器有两种端口，一种是用于连接结点的普通端口，另一种是用于级联的端口。\n"),t("ul",[t("li",[v._v("普通集线器只能通过多个集线器级联来扩展局域网的范围（构成树型结构），而堆叠式集线器可以通过堆叠端口将背板相互连接，逻辑上相当于一个集线器。")]),v._v(" "),t("li",[v._v("级联和堆叠都会将所有结点汇集到一个冲突域中。")])])])]),v._v(" "),t("h2",{attrs:{id:"端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#端口"}},[v._v("#")]),v._v(" 端口")]),v._v(" "),t("p",[v._v("计算机网络中的端口（port）有两种含义。")]),v._v(" "),t("ul",[t("li",[v._v("物理上的线路接口：比如路由器、交换机的端口。")]),v._v(" "),t("li",[v._v("逻辑上的网络端口：比如 TCP 80 端口常用于 HTTP 通信。")])])])}),[],!1,null,null,null);_.default=l.exports},779:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("ul",[t("li",[v._v("计算机网络是指将多台计算机及其外部设备通过通信线路连接起来，实现资源共享和数据通信。")]),v._v(" "),t("li",[v._v("计算机网络是计算机技术与通信技术的结合。")])]),v._v(" "),t("h2",{attrs:{id:"逻辑网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑网络"}},[v._v("#")]),v._v(" 逻辑网络")]),v._v(" "),t("p",[v._v("从逻辑上看，计算机网络分为两部分：")]),v._v(" "),t("ul",[t("li",[v._v("资源子网\n"),t("ul",[t("li",[v._v("负责数据处理，向用户提供网路服务。由主机、终端、外部设备等组成。")]),v._v(" "),t("li",[v._v("主机（host）：指任何有 IP 地址的计算机，它是资源子网的主要组成部分，普通终端通过主机连入网络。")]),v._v(" "),t("li",[v._v("终端：指处于计算机网络最终环节、供用户访问网络的设备，比如手机、笔记本属于移动终端。早期，由于计算机昂贵，往往多个输入输出设备共用一个主机，每个设备就是一个终端。现在，终端与计算机往往混为一谈。")])])]),v._v(" "),t("li",[v._v("通信子网\n"),t("ul",[t("li",[v._v("负责数据通信处理。由通信控制处理机、通信线路等组成。")]),v._v(" "),t("li",[v._v("通信控制处理机就是通信网络中的网络结点，最早的通信控制处理机是阿帕网中的接口报文处理机（IMP），它就是早期的路由器。")]),v._v(" "),t("li",[v._v("资源子网中的单个设备称为端点，通信子网中的单个设备称为结点。")])])])])])}),[],!1,null,null,null);_.default=l.exports},801:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("ul",[t("li",[v._v("程序：本质上是一组计算机指令代码，能让计算机执行某种操作。")]),v._v(" "),t("li",[v._v("编程：泛指编写计算机程序的过程。\n"),t("ul",[t("li",[v._v("编写程序代码之后，再执行程序代码，即可控制计算机完成某些任务。")])])]),v._v(" "),t("li",[v._v("编程语言：泛指可用于编写程序代码的语言。")])]),v._v(" "),t("h2",{attrs:{id:"语言分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语言分类"}},[v._v("#")]),v._v(" 语言分类")]),v._v(" "),t("h3",{attrs:{id:"机器、汇编、高级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#机器、汇编、高级"}},[v._v("#")]),v._v(" 机器、汇编、高级")]),v._v(" "),t("p",[v._v("将编程语言根据可读性分类：")]),v._v(" "),t("ul",[t("li",[v._v("机器语言\n"),t("ul",[t("li",[v._v("：由二进制代码 1 和 0 组成，几乎没有可读性。")]),v._v(" "),t("li",[v._v("能直接被计算机识别、执行，但是不能移植到不同操作系统上运行。")])])]),v._v(" "),t("li",[v._v("汇编语言\n"),t("ul",[t("li",[v._v("：用助记符编写程序，又称为符号语言。有基本的可读性，但是仍然难以记忆。")]),v._v(" "),t("li",[v._v("汇编语言编写的代码要通过汇编（即翻译）转换成机器语言才能运行。")])])]),v._v(" "),t("li",[v._v("高级语言\n"),t("ul",[t("li",[v._v("：模仿自然语言的语法进行编程，可读性好。")]),v._v(" "),t("li",[v._v("与高级语言相比，机器语言和汇编语言都是低级语言。")])])])]),v._v(" "),t("h3",{attrs:{id:"编译、解释、脚本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译、解释、脚本"}},[v._v("#")]),v._v(" 编译、解释、脚本")]),v._v(" "),t("p",[v._v("将编程语言根据运行方式分类：")]),v._v(" "),t("ul",[t("li",[v._v("编译型语言\n"),t("ul",[t("li",[v._v("：代码通过编译器（先翻译再执行）转换成机器语言之后才能运行。比如 C、C++ 语言。")]),v._v(" "),t("li",[v._v("程序在编译之后几乎不能移植。")])])]),v._v(" "),t("li",[v._v("解释型语言\n"),t("ul",[t("li",[v._v("：代码不需要编译，在运行时才通过解释器（边翻译边执行）转换成机器语言。比如 Java、C# 语言。")]),v._v(" "),t("li",[v._v("程序容易移植到不同平台。")])])]),v._v(" "),t("li",[v._v("脚本语言\n"),t("ul",[t("li",[v._v("：属于解释型语言、动态语言。比如 Shell、Python 语言。")]),v._v(" "),t("li",[v._v("可以不编译就即时执行代码，可以逐行执行代码，便于调试。")]),v._v(" "),t("li",[v._v("一般而言，编译型语言、解释型语言、脚本语言的运行速度、效率依次递减。")]),v._v(" "),t("li",[v._v("脚本语言刚诞生时功能简单，如今已经进化得像编译型语言一样功能强大。而且现在计算机硬件性能提升了很多，使用脚本语言也可以达到很好的性能。")])])])]),v._v(" "),t("h3",{attrs:{id:"gpl、dsl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpl、dsl"}},[v._v("#")]),v._v(" GPL、DSL")]),v._v(" "),t("p",[v._v("将编程语言根据使用场景分类：")]),v._v(" "),t("ul",[t("li",[v._v("通用编程语言（General Purpose Language ，GPL）")]),v._v(" "),t("li",[v._v("领域特定语言（Domain Specific Language ， DSL）\n"),t("ul",[t("li",[v._v("主要用于（甚至只能用于）某个领域，但在该领域的使用效果很可能比通用编程语言更好。")]),v._v(" "),t("li",[v._v("比如用于描述 Web 页面的 HTML、CSS 语言，用于数据库结构化查询的 SQL 语言，用于匹配字符串的正则表达式，用于 Linux 终端操作的 Shell 语言。")])])])]),v._v(" "),t("h2",{attrs:{id:"语法分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法分类"}},[v._v("#")]),v._v(" 语法分类")]),v._v(" "),t("h3",{attrs:{id:"弱类型、强类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#弱类型、强类型"}},[v._v("#")]),v._v(" 弱类型、强类型")]),v._v(" "),t("p",[v._v("根据是否自动转换数据类型来分类：")]),v._v(" "),t("ul",[t("li",[v._v("弱类型\n"),t("ul",[t("li",[v._v("：支持自动转换数据类型。")]),v._v(" "),t("li",[v._v("例如在 C 语言中："),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("float")]),v._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])])])])]),v._v(" "),t("li",[v._v("强类型\n"),t("ul",[t("li",[v._v("：不支持自动转换数据类型。")]),v._v(" "),t("li",[v._v("强类型并不是绝对的的概念，一个编程语言可能同时具有强类型、弱类型的语法。比如在 Python 中："),t("div",{staticClass:"language-py line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-py"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">>")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">>")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'1.0'")]),v._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 同一个变量可以执行不同类型的赋值，这是因为改变了变量引用的对象，体现了 Python 是动态类型语言")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">>")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'1.0'")]),v._v("   "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 不同类型的值不支持混合运算，体现了 Python 是弱类型语言，但用户可以重载 __add__() 方法来实现混合运算")]),v._v("\nTypeError"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" unsupported operand "),t("span",{pre:!0,attrs:{class:"token builtin"}},[v._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("for")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'int'")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("and")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'str'")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br")])])])])])]),v._v(" "),t("h3",{attrs:{id:"静态类型、动态类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态类型、动态类型"}},[v._v("#")]),v._v(" 静态类型、动态类型")]),v._v(" "),t("p",[v._v("根据编译时是否检查数据类型来分类：")]),v._v(" "),t("ul",[t("li",[v._v("静态类型语言（statically typed language）\n"),t("ul",[t("li",[v._v("：在程序编译之后，变量的数据类型不能再改变。")]),v._v(" "),t("li",[v._v("通常在程序编译时就检查数据类型，如果数据类型不符合要求，则中断编译，并报错。")])])]),v._v(" "),t("li",[v._v("动态类型语言（dynamically typed language）\n"),t("ul",[t("li",[v._v("：在程序编译之后，变量的数据类型可以改变。")]),v._v(" "),t("li",[v._v("通常在程序运行时才检查数据类型，如果数据类型不符合要求，可能会报错，也可能不会发现。")]),v._v(" "),t("li",[v._v("优点：使用变量时可以很灵活。")]),v._v(" "),t("li",[v._v("缺点：容易忽视数据类型的错误。")])])])]),v._v(" "),t("h3",{attrs:{id:"静态编程、动态编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态编程、动态编程"}},[v._v("#")]),v._v(" 静态编程、动态编程")]),v._v(" "),t("p",[v._v("根据程序在编译后能否改变来分类：")]),v._v(" "),t("ul",[t("li",[v._v("静态编程语言（dynamic programming language）\n"),t("ul",[t("li",[v._v("：在程序编译时确定了程序结构，不能改变。")]),v._v(" "),t("li",[v._v("大多是静态类型语言。")])])]),v._v(" "),t("li",[v._v("动态编程语言（dynamic programming language）\n"),t("ul",[t("li",[v._v("：在程序运行时可以改变程序结构，比如改变函数、改变代码。")]),v._v(" "),t("li",[v._v("大多是动态类型语言。")]),v._v(" "),t("li",[v._v("鸭子类型（duck typing）：如果一只鸟走起来像鸭子，游起来像鸭子，叫起来也像鸭子，那它就是一只鸭子。\n"),t("ul",[t("li",[v._v("鸭子类型体现了动态语言的特点 —— 只要一个类提供了鸭子类该有的属性和方法 walk()、swim()、quack() ，就可以将它当做一个鸭子类使用。")])])])])])]),v._v(" "),t("h2",{attrs:{id:"编程范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编程范式"}},[v._v("#")]),v._v(" 编程范式")]),v._v(" "),t("p",[v._v("编程范式（Programming Paradigms）：泛指编写代码的风格。有的编程语言的语法较自由，支持多种编程范式；有的编程语言的语法较严格，只支持特定的编程范式。")]),v._v(" "),t("h3",{attrs:{id:"面向过程编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向过程编程"}},[v._v("#")]),v._v(" 面向过程编程")]),v._v(" "),t("p",[v._v("：Process-oriented Programming 。指按解决问题的步骤一步步编写代码。")]),v._v(" "),t("ul",[t("li",[v._v("优点：流程简单、稳定。")]),v._v(" "),t("li",[v._v("缺点：前后代码高度耦合，可扩展性差。")])]),v._v(" "),t("h3",{attrs:{id:"面向对象编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程"}},[v._v("#")]),v._v(" 面向对象编程")]),v._v(" "),t("p",[v._v("：Object Oriented Programming（OOP）。指将代码封装成类，抽象化。")]),v._v(" "),t("ul",[t("li",[v._v("优点：能大大提高代码的复用性，便于编写大型程序。")]),v._v(" "),t("li",[v._v("缺点：一个类下的各个方法之间容易耦合，有继承关系的类之间容易耦合。因此维护一个类的成本比维护一个函数大很多。")])]),v._v(" "),t("h3",{attrs:{id:"结构化编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构化编程"}},[v._v("#")]),v._v(" 结构化编程")]),v._v(" "),t("p",[v._v("：Structured Programming 。指编程时采用顺序、选择、循环、递归等控制结构，自顶向下，逐步设计。")]),v._v(" "),t("ul",[t("li",[v._v("将一个语句块视作一个语句处理。")]),v._v(" "),t("li",[v._v("是对面向过程编程的改进，使流程更清晰。")])]),v._v(" "),t("h3",{attrs:{id:"函数式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[v._v("#")]),v._v(" 函数式编程")]),v._v(" "),t("p",[v._v("：Functional Programming 。编写函数时像编写数学函数，主要考虑给定输入参数时返回什么值，不会主动影响函数外部，不会影响程序的行为。")]),v._v(" "),t("ul",[t("li",[v._v("使函数高度解耦，常用于声明式编程。")])]),v._v(" "),t("h3",{attrs:{id:"命令式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令式编程"}},[v._v("#")]),v._v(" 命令式编程")]),v._v(" "),t("p",[v._v("：Imperative Programming 。主要考虑让程序执行什么操作，从而得到某种结果。")]),v._v(" "),t("ul",[t("li",[v._v("代码面向过程，很流程化，可扩展性差。")]),v._v(" "),t("li",[v._v("例如脚本语言。")])]),v._v(" "),t("h3",{attrs:{id:"声明式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#声明式编程"}},[v._v("#")]),v._v(" 声明式编程")]),v._v(" "),t("p",[v._v("：Declarative Programming 。主要描述想得到什么结果，不考虑程序的具体操作。")]),v._v(" "),t("ul",[t("li",[v._v("例如 SQL 语言、正则表达式。")])]),v._v(" "),t("h3",{attrs:{id:"符号式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#符号式编程"}},[v._v("#")]),v._v(" 符号式编程")]),v._v(" "),t("p",[v._v("：Symbolic Programming 。可以定义实现某种功能的表达式。")]),v._v(" "),t("ul",[t("li",[v._v("与函数相比，这样的代码更接近数学表达式，更直观。")]),v._v(" "),t("li",[v._v("例如 Lisp 语言中用表达式 "),t("code",[v._v("(+ 1 2)")]),v._v(" 来求和，而不是函数 "),t("code",[v._v("sum(1, 2)")]),v._v(" 。")])]),v._v(" "),t("h3",{attrs:{id:"元编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元编程"}},[v._v("#")]),v._v(" 元编程")]),v._v(" "),t("p",[v._v("：Meta Programming 。指程序运行时可以修改自己或其它程序的代码。")]),v._v(" "),t("ul",[t("li",[v._v("所有编译器、解释器、DSL 都属于元编程，一般语言的反射、泛型也属于元编程。")])]),v._v(" "),t("h2",{attrs:{id:"相关概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[v._v("#")]),v._v(" 相关概念")]),v._v(" "),t("h3",{attrs:{id:"耦合度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#耦合度"}},[v._v("#")]),v._v(" 耦合度")]),v._v(" "),t("p",[v._v("：Coupling ，指程序或代码之间联系的紧密程度，影响到它们能否独立运行。")]),v._v(" "),t("ul",[t("li",[v._v("比如程序 A 运行时需要调用程序 B ，代码 A 运行时需要读取代码 B 中的变量。")]),v._v(" "),t("li",[v._v("在模块化编程时，应该尽量降低耦合度，便于随时更换模块，提高可扩展性。")])]),v._v(" "),t("h3",{attrs:{id:"语法糖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法糖"}},[v._v("#")]),v._v(" 语法糖")]),v._v(" "),t("p",[v._v("：Syntactic Sugar 。泛指一些提升代码的可读性的语法，但不一定能优化程序的运行效率。")]),v._v(" "),t("ul",[t("li",[v._v("例如 Python 中的列表生成式。")])]),v._v(" "),t("h3",{attrs:{id:"api、abi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api、abi"}},[v._v("#")]),v._v(" API、ABI")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("API（Application Programming Interface，程序编程接口）")]),v._v(" "),t("ul",[t("li",[v._v("指一个程序提供的某个接口，可供其它程序在代码中调用，用于实现某种功能。例如：\n"),t("ul",[t("li",[v._v("一个 C 语言程序可以在头文件中声明函数形式的 API ，供其它程序调用。")]),v._v(" "),t("li",[v._v("一个 Web 服务器可以提供 HTTP 形式的 API ，供其它程序发出 HTTP 请求来调用。")])])]),v._v(" "),t("li",[v._v("如果一个程序提供了某个 API ，另一个程序也提供了相同的 ABI ，则其它程序可以通过相同的方式（比如用同一段代码）与这两个程序交互，称为兼容。")])])]),v._v(" "),t("li",[t("p",[v._v("ABI（Application Binary Interface，程序二进制接口）")]),v._v(" "),t("ul",[t("li",[v._v("是比 API 更底层的概念，主要考虑编译成二进制形式的应用程序，如何与编译器、操作系统等底层软件交互。例如：\n"),t("ul",[t("li",[v._v("调用函数时是通过寄存器还是别的方式传递参数。")]),v._v(" "),t("li",[v._v("如何管理堆栈。")]),v._v(" "),t("li",[v._v("如何传递异常。")])])]),v._v(" "),t("li",[v._v("如果某两个操作系统的 ABI 兼容，则可以将其中一个操作系统上的二进制程序，拷贝到另一个操作系统上运行。")])])])])])}),[],!1,null,null,null);_.default=l.exports},845:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("多种编程语言混合开发的形式：")]),v._v(" "),t("ul",[t("li",[v._v("调用可执行文件。")]),v._v(" "),t("li",[v._v("每种语言分别运行一个进程，让它们通信、协作。（通过本机 socket 或 HTTP 协议通信）")]),v._v(" "),t("li",[v._v("调用代码（比如调用函数、类）。")])]),v._v(" "),t("p",[v._v("使用 CPython 解释器时，可以进行 Python 与 C/C++ 的混合开发：")]),v._v(" "),t("ul",[t("li",[v._v("Python 调用 C/C++ 代码的形式：\n"),t("ul",[t("li",[v._v("把 C/C++ 代码编译成 C/C++ 的动态链接库，再被 Python 导入。")]),v._v(" "),t("li",[v._v("把 C/C++ 代码封装成 Python 的扩展模块，再被 Python 导入。")])])]),v._v(" "),t("li",[v._v("C/C++ 调用 Python 代码的形式：\n"),t("ul",[t("li",[v._v("把 Python 代码转换成 C/C++ 的动态链接库，再被 C/C++ 导入。")]),v._v(" "),t("li",[v._v("把 Python 代码转换成 C/C++ 的源文件，再被 C/C++ 导入。")])])])]),v._v(" "),t("h2",{attrs:{id:"混合开发工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混合开发工具"}},[v._v("#")]),v._v(" 混合开发工具")]),v._v(" "),t("p",[v._v("混合开发工具有多种，选择它们时需要从多方面考虑，比如：")]),v._v(" "),t("ul",[t("li",[v._v("是否支持 C/C++ 调用 Python ？或者反之？")]),v._v(" "),t("li",[v._v("调用函数时，是把形参从 Python 的数据类型转换成 C/C++ 的数据类型吗？或者反之？")]),v._v(" "),t("li",[v._v("进一步地，哪些数据类型可以通用？哪些数据类型不兼容？")]),v._v(" "),t("li",[v._v("能否调用类？")]),v._v(" "),t("li",[v._v("如果 C/C++ 代码抛出了异常，如何传递给 Python ？或者反之？")]),v._v(" "),t("li",[v._v("能否移植到 Linux、Windows、MacOS 等多种平台？")])]),v._v(" "),t("h3",{attrs:{id:"cpython-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpython-api"}},[v._v("#")]),v._v(" CPython API")]),v._v(" "),t("ul",[t("li",[v._v("：可以将 C/C++ 代码封装成 Python 模块，或者将 Python 代码封装成 C 代码。")]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("它是 CPython 解释器自带的功能，不需要安装第三方库。")]),v._v(" "),t("li",[v._v("它是实现 Python 混合开发的底层 API ，是其它混合开发工具的基础。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("使用起来很麻烦。")])])])]),v._v(" "),t("h3",{attrs:{id:"ctypes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ctypes"}},[v._v("#")]),v._v(" ctypes")]),v._v(" "),t("ul",[t("li",[v._v("：Python 的标准库，允许 Python 加载 C 的动态链接库，直接调用其中的函数，或者将 Python 函数作为回调函数传给 C 函数。")]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("它是 Python 自带的标准库，不需要安装第三方库。")]),v._v(" "),t("li",[v._v("使用时不需要封装 C 代码，可以直接调用 C 的动态链接库。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("没有封装 C 函数，因此 Python 调用一个 C 函数时要自己转换数据类型。")]),v._v(" "),t("li",[v._v("只支持 C 语言，处理 C++ 代码时要先封装成 C 函数。")]),v._v(" "),t("li",[v._v("不支持 C/C++ 主动调用 Python 。")])])])]),v._v(" "),t("h3",{attrs:{id:"cython"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cython"}},[v._v("#")]),v._v(" Cython")]),v._v(" "),t("ul",[t("li",[v._v("：Python 的第三方库，可以将 C 代码封装成 Python 模块，或者将 Python 代码编译成 C 代码。")]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("可以在 Python 中使用 C/C++ 的数据类型、函数，扩展 Python 的语法，提高 Python 程序的运行效率。")])])])]),v._v(" "),t("h3",{attrs:{id:"swig"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#swig"}},[v._v("#")]),v._v(" SWIG")]),v._v(" "),t("ul",[t("li",[v._v("：一个编译器，可以将 C/C++ 代码封装成供 C#、Java、Python 等多种语言调用的文件。")]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("不支持 C/C++ 主动调用 Python 。")])])])]),v._v(" "),t("h3",{attrs:{id:"boost-python"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#boost-python"}},[v._v("#")]),v._v(" Boost.Python")]),v._v(" "),t("ul",[t("li",[v._v("：一个 C++ 库，可以将 C++ 代码封装成 Python 模块，或者在 C++ 中导入 Python 模块。")]),v._v(" "),t("li",[v._v("Boost 库的使用很广，提供了一些扩展功能的 C++ 库，近乎 C++ 的标准库。")])]),v._v(" "),t("h3",{attrs:{id:"pybind11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pybind11"}},[v._v("#")]),v._v(" pybind11")]),v._v(" "),t("ul",[t("li",[v._v("：一个 C++ 库，相当于轻量级的 Boost.Python 。")]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("比较简单，使用时只需要导入一个头文件。但功能完备。")]),v._v(" "),t("li",[v._v("对 C/C++ 代码的封装比较完善，能加上模块说明、函数说明。")])])])])])}),[],!1,null,null,null);_.default=l.exports},853:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("当一个程序需要执行多个任务时，主要有两种策略：")]),v._v(" "),t("ul",[t("li",[v._v("只使用一个线程，串行执行。")]),v._v(" "),t("li",[v._v("创建多进程或多线程，并行执行。")])]),v._v(" "),t("h2",{attrs:{id:"多进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多进程"}},[v._v("#")]),v._v(" 多进程")]),v._v(" "),t("p",[v._v("多进程（multiprocess）的优点：")]),v._v(" "),t("ul",[t("li",[v._v("每个进程使用的内存、虚拟地址空间等资源相互独立，不会冲突。")]),v._v(" "),t("li",[v._v("每个进程独立运行，一个进程挂掉了不会影响其它进程。")])]),v._v(" "),t("h2",{attrs:{id:"多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[v._v("#")]),v._v(" 多线程")]),v._v(" "),t("p",[v._v("多线程（multithreading）的优点：")]),v._v(" "),t("ul",[t("li",[v._v("与单线程相比，可以提高 CPU 的使用率。\n"),t("ul",[t("li",[v._v("比如一个线程因为等待 IO 而暂停运行时，其它线程依然可以运行。")]),v._v(" "),t("li",[v._v("比如一个线程占用了 CPU 的一个核时，其它线程可以在 CPU 的其它核上运行。")]),v._v(" "),t("li",[v._v("处理 IO 密集型任务时，多进程、多线程可以提高 CPU 的使用率，从而提高处理速度。处理 CPU 密集型任务时，多进程、多线程不能提高处理速度。")])])]),v._v(" "),t("li",[v._v("多线程相当于轻量级的多进程，开销更小。\n"),t("ul",[t("li",[v._v("创建进程比创建线程的开销更大，需要重新分配系统资源。")]),v._v(" "),t("li",[v._v("CPU 切换进程时，不仅需要切换运行的线程，还需要切换进程所分配的内存、堆栈等资源。")])])]),v._v(" "),t("li",[v._v("与进程间通信相比，线程间通信更容易。\n"),t("ul",[t("li",[v._v("同一个进程的多个线程之间可以采用全局变量作为通信媒介，因为它们访问的是同一个堆区。")])])])]),v._v(" "),t("h3",{attrs:{id:"线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[v._v("#")]),v._v(" 线程安全")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("线程是 CPU 调度的基本单位。系统会决定由 CPU 的哪个核来执行线程、执行多长时间。")]),v._v(" "),t("ul",[t("li",[v._v("创建多进程时，各个进程会按启动顺序，顺序执行。")]),v._v(" "),t("li",[v._v("创建多线程时，各个线程的运行顺序无法预测。（因为负载变化时，CPU 的调度情况就可能变化）")])])]),v._v(" "),t("li",[t("p",[v._v("运行多线程时可能出现以下问题：")]),v._v(" "),t("ul",[t("li",[v._v("一个线程在执行任务时，被其它线程打断。\n"),t("ul",[t("li",[v._v("可以阻塞其它线程，先让该线程运行完该任务。")])])]),v._v(" "),t("li",[v._v("一个线程在访问共享资源时，该资源被其它线程修改。\n"),t("ul",[t("li",[v._v("可以给该资源上锁，保证同时只能被一个线程访问。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"线程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[v._v("#")]),v._v(" 线程间通信")]),v._v(" "),t("ul",[t("li",[v._v("线程间通信的常见方式：\n"),t("ul",[t("li",[v._v("轮询（poll）：主线程循环去检查子线程的状态，这会浪费一些主线程的时间，")]),v._v(" "),t("li",[v._v("回调（callback）：子线程执行结束后调用主线程的一个函数或方法。")])])])]),v._v(" "),t("h2",{attrs:{id:"并行与并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并行与并发"}},[v._v("#")]),v._v(" 并行与并发")]),v._v(" "),t("ul",[t("li",[v._v("串行工作（Serial）\n"),t("ul",[t("li",[v._v("：一个程序同时只能执行一个任务，执行完之后才能执行下一个任务。")]),v._v(" "),t("li",[v._v("例如每个线程都是串行工作的，同时只能顺序执行一段代码。")])])]),v._v(" "),t("li",[v._v("并行工作（Parallel）\n"),t("ul",[t("li",[v._v("：一个程序同时执行多个任务。")]),v._v(" "),t("li",[v._v("例如程序可以有多个线程，同时运行在多个 CPU 上。")])])]),v._v(" "),t("li",[v._v("并发工作（Concurrent）\n"),t("ul",[t("li",[v._v("：一个程序同时处理多个任务，但不一定会同时执行。即上一个任务没有执行完，就可以处理下一个任务。")]),v._v(" "),t("li",[v._v("例如程序可以有多个线程，交替运行运行在一个 CPU 上。")])])])])])}),[],!1,null,null,null);_.default=l.exports},859:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("CMS ：内容管理系统（Content Management System）")]),v._v(" "),t("ul",[t("li",[v._v("泛指让用户发布、编辑、管理内容的网站，比如博客、论坛、新闻网站。")]),v._v(" "),t("li",[v._v("很多 CMS 只用于简单地发布消息，因此做成了静态网站。")])])])}),[],!1,null,null,null);_.default=l.exports},867:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"web-服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-服务器"}},[v._v("#")]),v._v(" Web 服务器")]),v._v(" "),t("ul",[t("li",[v._v("Web 服务器软件有很多种，基本都支持用作静态服务器，但用作动态服务器时，可能只支持部分类型的 Web 应用。")]),v._v(" "),t("li",[v._v("Web 服务器软件举例：\n"),t("ul",[t("li",[v._v("Apache HTTP Server\n"),t("ul",[t("li",[v._v("：简称为 Apache ，采用 C 语言开发，支持 CGI 应用。")])])]),v._v(" "),t("li",[v._v("Nginx\n"),t("ul",[t("li",[v._v("：采用 C 语言开发，支持 FastCGI、WSGI 应用。")])])]),v._v(" "),t("li",[v._v("IIS（Internet Information Server）\n"),t("ul",[t("li",[v._v("：Windows 系统自带的一个服务器，是闭源软件，采用 C++ 开发。")])])]),v._v(" "),t("li",[v._v("Tomcat\n"),t("ul",[t("li",[v._v("：采用 Java 开发，支持 CGI、Java Servlet 应用。")])])]),v._v(" "),t("li",[v._v("Jetty\n"),t("ul",[t("li",[v._v("：采用 Java 开发，与 Tomcat 类似。")])])]),v._v(" "),t("li",[v._v("uWSGI\n"),t("ul",[t("li",[v._v("：采用 C 语言开发，通过自带的 uwsgi 协议实现了 WSGI 接口。")]),v._v(" "),t("li",[v._v("用 Python 的 Django、Flask 框架开发的 WSGI 应用，可以部署到 uWSGI 服务器上运行。")])])])])])]),v._v(" "),t("h2",{attrs:{id:"前后端架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端架构"}},[v._v("#")]),v._v(" 前后端架构")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("前后端合一")]),v._v(" "),t("ul",[t("li",[v._v("：由一台服务器接收 HTTP 请求并返回 HTTP 响应。")]),v._v(" "),t("li",[v._v("结构较简单，但可扩展性较差，适合小型网站。")])])]),v._v(" "),t("li",[t("p",[v._v("前后端分离")]),v._v(" "),t("ul",[t("li",[v._v("：由前端（front-end）服务器处理客户端的静态请求，遇到动态请求时才转发给后端（back-end）服务器处理。")]),v._v(" "),t("li",[v._v("有利于解耦、分布式集群、提高前端效率、降低后端压力。")]),v._v(" "),t("li",[v._v("前端服务器通常是静态服务器，后端服务器通常是动态服务器。")]),v._v(" "),t("li",[v._v("前端、后端服务器之间通常通过 RESTful API 进行通信。")])])])]),v._v(" "),t("h2",{attrs:{id:"静态服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态服务器"}},[v._v("#")]),v._v(" 静态服务器")]),v._v(" "),t("p",[v._v("：收到 HTTP 静态请求时能直接拿出静态资源回复，但不能处理 HTTP 动态请求。")]),v._v(" "),t("ul",[t("li",[v._v("主要用途：\n"),t("ul",[t("li",[v._v("独立运行一个静态网站。")]),v._v(" "),t("li",[v._v("在前后端分离架构中，用作前端服务器。")])])])]),v._v(" "),t("h3",{attrs:{id:"静态资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态资源"}},[v._v("#")]),v._v(" 静态资源")]),v._v(" "),t("p",[v._v("：不会变化的数据或文件。比如 html 文件、js 文件、css 文件、图片、视频。")]),v._v(" "),t("h3",{attrs:{id:"静态网站"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态网站"}},[v._v("#")]),v._v(" 静态网站")]),v._v(" "),t("p",[v._v("：只能提供静态资源的网站，其显示内容、行为都是预设好的，大多不能变化。")]),v._v(" "),t("ul",[t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("只负责处理 HTTP 静态请求，因此访问速度比动态网站快很多。")]),v._v(" "),t("li",[v._v("运行开销很小，甚至 GitHub Pages 等平台愿意免费帮用户运行静态网站。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("与用户的交互性差，不能接收、存储用户的数据。")])])])]),v._v(" "),t("h2",{attrs:{id:"动态服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态服务器"}},[v._v("#")]),v._v(" 动态服务器")]),v._v(" "),t("p",[v._v("：不止能处理 HTTP 静态请求，还能处理 HTTP 动态请求。")]),v._v(" "),t("ul",[t("li",[v._v("动态服务器上通常需要运行一些程序来处理 HTTP 动态请求，它们被称为 Web 应用、后端程序，可以用 Java、JS、PHP、Python 等语言开发。\n"),t("ul",[t("li",[v._v("Web 应用与 Web 服务器的通信接口分为多种类型，比如 CGI、FastCGI 等。")])])])]),v._v(" "),t("h3",{attrs:{id:"cgi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cgi"}},[v._v("#")]),v._v(" CGI")]),v._v(" "),t("p",[v._v("：通用网关接口（Common Gateway Interface），一种 Web 服务器与 Web 应用之间的通信协议，工作在应用层。")]),v._v(" "),t("ul",[t("li",[v._v("该协议与编程语言无关，用 C、C++、php、Perl 等语言都可以开发 CGI 程序。")]),v._v(" "),t("li",[v._v("服务器的工作流程：\n"),t("ol",[t("li",[v._v("服务器收到一个 HTTP 请求。")]),v._v(" "),t("li",[v._v("服务器创建一个新的 CGI 进程，并将请求的内容写入 stdin 和环境变量。")]),v._v(" "),t("li",[v._v("CGI 进程读取请求的内容，进行处理，将响应写入 stdout ，然后退出进程。")]),v._v(" "),t("li",[v._v("服务器读取响应，发送给客户端。\n每收到一个 HTTP 请求就要重复上述过程，因此并发效率很低。")])])])]),v._v(" "),t("h3",{attrs:{id:"fastcgi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fastcgi"}},[v._v("#")]),v._v(" FastCGI")]),v._v(" "),t("p",[v._v("：改进了 CGI ，提高了工作效率。")]),v._v(" "),t("ul",[t("li",[v._v("服务器启动时，先创建一个 master 进程，负责解析配置文件、管理全局。再创建多个 worker 进程并保持运行，负责处理 HTTP 请求。")])]),v._v(" "),t("h3",{attrs:{id:"wsgi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wsgi"}},[v._v("#")]),v._v(" WSGI")]),v._v(" "),t("p",[v._v("：Web 服务器网关接口（Web Server Gateway Interface），与 CGI 类似。")]),v._v(" "),t("ul",[t("li",[v._v("定义了 server、application 两个角色，server 负责完成 HTTP 通信，application 负责业务逻辑，两者之间解耦。\n"),t("ul",[t("li",[v._v("比如当客户端发来 HTTP request 时，server 会将它解析并传给 application 。application 处理之后会生成 HTTP response 并让 server 发送。")])])]),v._v(" "),t("li",[v._v("该规范没有明确协议，且与编程语言无关。最初只有 Python 支持 WSGI ，后来 Ruby、Java 等语言也开始支持。")])]),v._v(" "),t("h3",{attrs:{id:"asgi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asgi"}},[v._v("#")]),v._v(" ASGI")]),v._v(" "),t("p",[v._v("：异步网关协议接口（Asynchronous Server Gateway Interface），为 WSGI 的超集。")]),v._v(" "),t("ul",[t("li",[v._v("支持异步请求。")]),v._v(" "),t("li",[v._v("支持 HTTP/1 、HTTP/2 、WebSocket 协议。")])])])}),[],!1,null,null,null);_.default=l.exports},876:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"前端语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端语言"}},[v._v("#")]),v._v(" 前端语言")]),v._v(" "),t("p",[v._v("早期的 Web 网页只有单纯的 HTML 文件，功能简单。后来发明了 CSS、JavaScript 等技术，丰富了网页的功能。这三种技术是前端开发的基础。")]),v._v(" "),t("ul",[t("li",[v._v("HTML ：负责控制网页的内容。\n"),t("ul",[t("li",[v._v("只要有 HTML 文件，就能让 Web 浏览器显示出网页。")])])]),v._v(" "),t("li",[v._v("CSS ：负责控制网页的显示样式、排版。")]),v._v(" "),t("li",[v._v("JavaScript ：负责控制网页的行为。")])]),v._v(" "),t("h2",{attrs:{id:"前端开发框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端开发框架"}},[v._v("#")]),v._v(" 前端开发框架")]),v._v(" "),t("ul",[t("li",[v._v("Bootstrap ：一个 CSS/HTML 开发框架，由 Twitter 推出。")]),v._v(" "),t("li",[v._v("jQuery ：一个 JS 库。")]),v._v(" "),t("li",[v._v("AngularJS ：一个 JS 开发框架，由 Google 推出。")]),v._v(" "),t("li",[v._v("ReactJS ：一个 JS 开发框架，由 Facebook 推出。")]),v._v(" "),t("li",[v._v("Vue.js ：一个 JS 开发框架。")])]),v._v(" "),t("h2",{attrs:{id:"相关概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[v._v("#")]),v._v(" 相关概念")]),v._v(" "),t("ul",[t("li",[v._v(".svg 文件 ：可伸缩矢量图形，用 XML 文本描述图像。")]),v._v(" "),t("li",[v._v(".swf 文件 ：用于保存 flash 动画。")]),v._v(" "),t("li",[v._v("PV ：页面浏览量（Page Views），一般是统计网站的所有页面被访问的总次数，用户每刷新一次页面就加一次浏览量。")]),v._v(" "),t("li",[v._v("UV ：独立访客数（Unique Visitors），一般是统计访问网站的 IP 地址数。")]),v._v(" "),t("li",[v._v("DAU ：每日活跃用户数（Daily Active User），一般是统计每天的 UV 。")]),v._v(" "),t("li",[v._v("埋点 ：网站每次被用户访问时，让前端或后端记录下当前的上下文信息，便于运营人员进行大数据分析。比如用户 ID 、用户地址、操作事件、跳转的源网页和目标网页、驻留时长。")]),v._v(" "),t("li",[v._v("I18N ：国际化（Internationalization），通常指软件不需要修改，就能在不同国家、地区通用。")]),v._v(" "),t("li",[v._v("L10N ：本地化（Localization），通常指软件专门为某个国家、地区做出修改，比如显示本地语言、本地时间。")])]),v._v(" "),t("h3",{attrs:{id:"渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[v._v("#")]),v._v(" 渲染")]),v._v(" "),t("ul",[t("li",[v._v("渲染（Render）通常是指生成 HTML 文件的过程，渲染之后就可以在 Web 浏览器中查看。")]),v._v(" "),t("li",[v._v("通常有两种渲染策略：\n"),t("ul",[t("li",[v._v("服务器端渲染（Server Side Rendering ，SSR）\n"),t("ul",[t("li",[v._v("：服务器直接生成 HTML 文件，发送给浏览器。")])])]),v._v(" "),t("li",[v._v("客户端渲染（Client Side Rendering ，CSR）\n"),t("ul",[t("li",[v._v("：服务器发送 JS 文件等内容，由浏览器执行 JS 代码，生成最终的 HTML 文件。")]),v._v(" "),t("li",[v._v("优点：减少服务器的通信量，有利于针对客户端进行个性化显示。")]),v._v(" "),t("li",[v._v("缺点：需要浏览器消耗一定时间和性能进行渲染")])])])])]),v._v(" "),t("li",[v._v("另外，根据浏览器显示的 HTML 文件的内容能否变化对网页进行分类：\n"),t("ul",[t("li",[v._v("静态网页")]),v._v(" "),t("li",[v._v("动态网页")])])])]),v._v(" "),t("h3",{attrs:{id:"mpa-与-spa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mpa-与-spa"}},[v._v("#")]),v._v(" MPA 与 SPA")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("MPA")]),v._v(" "),t("ul",[t("li",[v._v("：多页面应用（Multiple Page Application）。网站的每个页面分别用一个 html 文件描述。")]),v._v(" "),t("li",[v._v("浏览器每跳转一个页面时都要请求一个相应的 html 文件，速度较慢。")])])]),v._v(" "),t("li",[t("p",[v._v("SPA")]),v._v(" "),t("ul",[t("li",[v._v("：单页面应用（Single Page Application）。用一个 html 文件显示多个网页，通过 JS 切换页面。")]),v._v(" "),t("li",[v._v("浏览器跳转页面的速度较快，因为不需要请求新的 html 文件。")]),v._v(" "),t("li",[v._v("加载第一个页面的速度较慢。")]),v._v(" "),t("li",[v._v("不利于 SEO ，因为搜索引擎不能获取到 JS 动态生成的内容。")]),v._v(" "),t("li",[v._v("开发 SPA 时通常要使用某种前端框架，比如 Vue 。")])])])]),v._v(" "),t("h3",{attrs:{id:"响应式布局设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式布局设计"}},[v._v("#")]),v._v(" 响应式布局设计")]),v._v(" "),t("p",[v._v("：指网页能根据终端的尺寸自动调整布局，为用户提供合适的页面。")]),v._v(" "),t("ul",[t("li",[v._v("原理：\n"),t("ul",[t("li",[v._v("通过 CSS3 中的 Media Query（媒体查询），可以获得终端的宽、高、分辨率、画面比例、横竖方向等信息，来决定布局方式。")]),v._v(" "),t("li",[v._v("设置元素的尺寸时，可以用百分比为单位，使它在不同尺寸的终端上的显示比例差不多。")]),v._v(" "),t("li",[v._v("当终端尺寸过小时，可以隐藏一些元素。")])])]),v._v(" "),t("li",[v._v("优点：能兼顾电脑、手机等不同终端的用户体验。")]),v._v(" "),t("li",[v._v("缺点：需要设计多种布局，成本较大。")])]),v._v(" "),t("h3",{attrs:{id:"cdn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[v._v("#")]),v._v(" CDN")]),v._v(" "),t("p",[v._v("：内容分发网络（Content Delivery Network），将网站的一些资源文件存储到各个地理位置的缓存服务器中，供客户端下载。")]),v._v(" "),t("ul",[t("li",[v._v("工作流程：\n"),t("ol",[t("li",[v._v("用户购买使用某个平台的 CDN 服务，给源域名 test.com 创建加速域名 cdn.test.com 。")]),v._v(" "),t("li",[v._v("用户在域名注册平台修改配置，给源域名 test.com 添加一个 CNAME ，指向 cdn.test.com 。")]),v._v(" "),t("li",[v._v("让客户端访问源域名。DNS 解析时发现存在 CNAME ，就将请求转发到加速域名。")]),v._v(" "),t("li",[v._v("CDN 服务器收到 HTTP 请求，将加速域名解析到距离客户端地理位置最近的缓存服务器。")]),v._v(" "),t("li",[v._v("缓存服务器收到 HTTP 请求，将资源文件返回给客户端。如果没有缓存该资源文件，则从源域名下载该文件并缓存。")])])]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("提高了客户端下载资源文件的速度。")]),v._v(" "),t("li",[v._v("减轻了原网站的流量压力。")])])])]),v._v(" "),t("h3",{attrs:{id:"webassembly"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webassembly"}},[v._v("#")]),v._v(" WebAssembly")]),v._v(" "),t("p",[v._v("：简称为 wasm ，是一种在浏览器沙盒中运行二进制程序的技术。")]),v._v(" "),t("ul",[t("li",[v._v("特点：\n"),t("ul",[t("li",[v._v("是独立的二进制程序，直接调用浏览器的 API ，不依赖 JS 。")]),v._v(" "),t("li",[v._v("执行速度接近原生代码。")])])]),v._v(" "),t("li",[v._v("2015 年发布，前身是 asm.js。\n"),t("ul",[t("li",[v._v("asm.js ：JS 语言的子集，可以将 C 语言代码翻译成 asm.js 代码之后，在浏览器中执行。")])])]),v._v(" "),t("li",[v._v("提供了 Emscripten 编译器，基于 LLVM 编译器，支持将 C、C++、C#、Go、Kotlin 等语言的代码编译成 wasm 模块。\n"),t("ul",[t("li",[v._v("例：用 Emscripten 编译 C 语言源文件"),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[v._v("emcc test.c -s "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[v._v("WASM")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" -o test.html\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),v._v("这会生成以下文件："),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[v._v("test.wasm   "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 二进制的 wasm 模块")]),v._v("\ntest.html   "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 一个示例 HTML 文件，可以调用 wasm 模块")]),v._v("\ntest.js     "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 一个起辅助作用的 JS 文件")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br")])])])])])])])}),[],!1,null,null,null);_.default=l.exports},887:function(v,_,t){"use strict";t.r(_);var a=t(1),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("h2",{attrs:{id:"rest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest"}},[v._v("#")]),v._v(" REST")]),v._v(" "),t("p",[v._v("：表述性状态转移（Representational State Transfer），是一种与 HTTP 协议相似的 HTTP API 规范。")]),v._v(" "),t("ul",[t("li",[v._v("主要规范：\n"),t("ul",[t("li",[v._v("将每个资源用一个唯一的 URL 标识。")]),v._v(" "),t("li",[v._v("URL 应该是名词性的，且区分单复数。比如 /students/names 要优于 /students/getName 。")]),v._v(" "),t("li",[v._v("主要使用 GET、POST、PUT、DELETE 四种 HTTP 方法，实现 CRUD 操作。")]),v._v(" "),t("li",[v._v("报文 body 通常采用 JSON 格式。")]),v._v(" "),t("li",[v._v("客户端与服务器之间采用无状态通信，所以客户端的每个请求都应该自带上下文信息。")])])]),v._v(" "),t("li",[v._v("符合 REST 规范的 API 称为 RESTful API 。\n"),t("ul",[t("li",[v._v("还有其它的 API 规范，比如模仿数据库的 CRUD 操作。")])])]),v._v(" "),t("li",[v._v("优点：\n"),t("ul",[t("li",[v._v("简单易懂，了解 HTTP 协议即可理解 REST 规范。")]),v._v(" "),t("li",[v._v("服务器与客户端基本解耦。")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[v._v("操作对象不一定是一个具体的资源，不一定适合用 URL 表示。")]),v._v(" "),t("li",[v._v("只有少数几种 HTTP 方法，不能体现某些特别的操作，比如既需要读、又需要写的操作。")])])])]),v._v(" "),t("h2",{attrs:{id:"rpc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rpc"}},[v._v("#")]),v._v(" RPC")]),v._v(" "),t("p",[v._v("：远程过程调用（Remote Procedure Call），是一种 API 规范，用于在本机代码中调用其它主机上的进程的方法。")]),v._v(" "),t("ul",[t("li",[v._v("常用于分布式系统中，实现不同主机的进程之间的相互调用。")]),v._v(" "),t("li",[v._v("RPC 与 REST 的区别：\n"),t("ul",[t("li",[v._v("RESET 只是 HTTP API 规范，而 RPC 是更抽象的 API 规范，可以采用 TCP、UDP、HTTP 等通信协议。")]),v._v(" "),t("li",[v._v("实现 RESTful API 只需要修改 HTTP 服务器的 API 行为 ，而实现 RPC 需要使用一个分布式框架。")])])]),v._v(" "),t("li",[v._v("gRPC ：一个 RPC 框架，基于 HTTP/2 协议，由 Google 公司发布。")])]),v._v(" "),t("h2",{attrs:{id:"graphql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphql"}},[v._v("#")]),v._v(" GraphQL")]),v._v(" "),t("p",[v._v("：一种查询语言，方便通过 API 查询图状数据。")]),v._v(" "),t("ul",[t("li",[v._v("2015 年，由 Facebook 公司发布。")]),v._v(" "),t("li",[v._v("用于 HTTP API 时，可视作 REST 的替代方案。")]),v._v(" "),t("li",[v._v("例：\n"),t("ol",[t("li",[v._v("客户端发出查询请求："),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  human"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("id: "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"2"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 查询指定 id 的 human 对象，要求返回指定字段的值")]),v._v("\n    name\n    age\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br")])])]),v._v(" "),t("li",[v._v("服务器返回响应："),t("div",{staticClass:"language-json line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v('"human"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v('"name"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"Leo"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v('"age"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("20")]),v._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br")])])])])])]),v._v(" "),t("h2",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[v._v("#")]),v._v(" WebSocket")]),v._v(" "),t("p",[v._v("：HTML5 标准定义的一个协议。")]),v._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[v._v("#")]),v._v(" 原理")]),v._v(" "),t("ul",[t("li",[v._v("属于应用层协议，基于 TCP 通信。")]),v._v(" "),t("li",[v._v("通过 HTTP 协议握手，步骤如下：\n"),t("ol",[t("li",[v._v("客户端发出一个 GET 请求，采用 HTTP/1.1 协议，请求头包含 "),t("code",[v._v("Upgrade: websocket")]),v._v(" 和 "),t("code",[v._v("Connection: Upgrade")]),v._v(" ，表示切换到 WebSocket 协议。")]),v._v(" "),t("li",[v._v("服务器返回一个响应报文，状态码为 101 (Switching Protocols) 。")]),v._v(" "),t("li",[v._v("双方通过该 HTTP 端口建立 TCP 长连接，进行全双工通信。")])])]),v._v(" "),t("li",[v._v("URL 分为两种格式：\n"),t("ul",[t("li",[v._v("ws ：格式为 "),t("code",[v._v("ws://host:port/path")]),v._v(" ，类似于 HTTP ，默认使用 TCP 80 端口。")]),v._v(" "),t("li",[v._v("wss ：格式为 "),t("code",[v._v("wss://host:port/path")]),v._v(" ，类似于 HTTPS ，默认使用 TCP 443 端口。")])])])]),v._v(" "),t("h3",{attrs:{id:"例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[v._v("#")]),v._v(" 例")]),v._v(" "),t("ul",[t("li",[v._v("客户端的 JS 代码示例："),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" ws "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("WebSocket")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"ws://10.0.0.1/test"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nws"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("send")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"Hello World!"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nws"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("close")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);