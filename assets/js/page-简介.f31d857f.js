(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{656:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),l("h2",{attrs:{id:"分布式系统"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统"}},[v._v("#")]),v._v(" 分布式系统")]),v._v(" "),l("p",[v._v("：是指将一个软件系统的各个进程分别部署不同主机上。")]),v._v(" "),l("ul",[l("li",[v._v("小型的软件系统通常只部署在一台计算机上，属于集中式系统。而大型的软件系统通常部署成分布式系统，从而提高性能。")]),v._v(" "),l("li",[v._v("优点：\n"),l("ul",[l("li",[v._v("便于横向增加系统节点，提高系统容量、性能，比如处理高并发流量。")]),v._v(" "),l("li",[v._v("可以将同一个应用运行多个实例，一个实例挂掉了就用其它实例，实现服务的高可用。")]),v._v(" "),l("li",[v._v("可以将一个数据存储多个副本，实现可靠的备份。")])])]),v._v(" "),l("li",[v._v("难点：\n"),l("ul",[l("li",[v._v("系统规模变大、结构变复杂，维护麻烦。")]),v._v(" "),l("li",[v._v("同一个应用要运行多个实例，占用资源的冗余多。")])])])]),v._v(" "),l("h2",{attrs:{id:"共识"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#共识"}},[v._v("#")]),v._v(" 共识")]),v._v(" "),l("p",[v._v("：Consensus ，指系统中不同节点作出的决策相同。")]),v._v(" "),l("ul",[l("li",[v._v("脑裂（brain split）\n"),l("ul",[l("li",[v._v("：指一个系统中存在多个有权决策的节点，并且作出了不同决策。")])])]),v._v(" "),l("li",[v._v("拜占庭将军问题（Byzantine Generals Problem）\n"),l("ul",[l("li",[v._v("：多个拜占庭将军自主观察敌情，然后通过投票决定进攻还是撤退。但可能存在不诚实的将军，或者投票信件被丢失、篡改。")]),v._v(" "),l("li",[v._v("该问题代表系统中某些节点传播虚假的信息，导致其它节点作出了错误决策。")])])])]),v._v(" "),l("h3",{attrs:{id:"paxos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[v._v("#")]),v._v(" Paxos")]),v._v(" "),l("p",[v._v("：一个共识算法，于 1990 年发布。")]),v._v(" "),l("ul",[l("li",[v._v("系统中一些节点担任 Proposer ，有权发出提议（Proposal）、投票。\n"),l("ul",[l("li",[v._v("其它节点担任 Acceptor ，有权投票。")])])]),v._v(" "),l("li",[v._v("每个提议需要超过半数的节点投票同意，才能通过。\n"),l("ul",[l("li",[v._v("这属于多数派（Majority）策略，允许低于半数的节点不可用。")])])])]),v._v(" "),l("h3",{attrs:{id:"raft"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#raft"}},[v._v("#")]),v._v(" Raft")]),v._v(" "),l("p",[v._v("：一个共识算法，在 Paxos 算法的基础上作了改进。")]),v._v(" "),l("ul",[l("li",[v._v("系统中有且仅有一个节点担任 Leader ，有权发出提议（Proposal）、投票。\n"),l("ul",[l("li",[v._v("其它节点担任 Follower ，有权投票。")])])]),v._v(" "),l("li",[v._v("每次准备修改集群数据时，Leader 会将该提议发送给所有 Follower ，等超过半数的节点同意并执行之后，才通过该提议，从而达成共识、数据一致性。\n"),l("ul",[l("li",[v._v("超过半数，又称为达到法定成员数（Quorum）。\n"),l("ul",[l("li",[v._v("当节点总数为 N 时，法定成员数为 "),l("code",[v._v("Quorum = N/2 + 1")]),v._v(" ，其中 / 为整除运算符。")]),v._v(" "),l("li",[v._v("Quorum 必须超过半数。如果允许 Quorum 等于集群半数，甚至小于半数，则集群就可能同时存在不止一个 leader ，发生脑裂。")])])]),v._v(" "),l("li",[v._v("并不会等到所有节点都同意，因此属于最终一致性。")]),v._v(" "),l("li",[v._v("该共识是容错的，允许 Quorum 之外的节点不可用。\n"),l("ul",[l("li",[v._v("增加节点总数可以提供系统可用性，但是会增加每次达成共识的耗时。")])])])])]),v._v(" "),l("li",[v._v("Leader 定期发送心跳包给其它节点。如果心跳超时，则其它节点变为 Candidate 状态，选举一个节点担任新 Leader 。")]),v._v(" "),l("li",[v._v("每次选出 Leader ，就开始一个新任期，称为 Term 。")]),v._v(" "),l("li",[v._v("每个节点都信任其它节点发来的信息，因此不能实现拜占庭容错。")])]),v._v(" "),l("h3",{attrs:{id:"bully"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#bully"}},[v._v("#")]),v._v(" Bully")]),v._v(" "),l("p",[v._v("：一个共识算法，与 Raft 算法相似。")]),v._v(" "),l("ul",[l("li",[v._v("如果 Leader 节点故障，则由 ID 最大的一个节点担任新 Leader 。")])]),v._v(" "),l("h3",{attrs:{id:"gossip"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#gossip"}},[v._v("#")]),v._v(" Gossip")]),v._v(" "),l("p",[v._v("：一个广播消息的协议，常用于 P2P 服务。")]),v._v(" "),l("ul",[l("li",[v._v("每个节点定期散播一次消息，最多发送给 k 个节点。\n"),l("ul",[l("li",[v._v("发送消息之后，不必确保对方接收。")]),v._v(" "),l("li",[v._v("其它节点收到消息之后，会散播给除了源节点之外的其它节点。")])])]),v._v(" "),l("li",[v._v("消息被病毒式传播，能实现最终一致性。")])]),v._v(" "),l("h3",{attrs:{id:"pow"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#pow"}},[v._v("#")]),v._v(" PoW")]),v._v(" "),l("p",[v._v("：工作量证明（Proof of Work），一个区块链的共识算法。")]),v._v(" "),l("ul",[l("li",[v._v("比特币采用基于哈希函数的 PoW 算法：\n"),l("ul",[l("li",[v._v("以区块为单位写入数据。")]),v._v(" "),l("li",[v._v("每个节点需要进行大量哈希运算，穷举猜测下一个区块的 nonce 随机数，第一个猜出来的节点有权生成该区块，然后广播给其它节点。")])])]),v._v(" "),l("li",[v._v("可实现顺序一致性，并实现拜占庭容错。")])]),v._v(" "),l("h3",{attrs:{id:"pos"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#pos"}},[v._v("#")]),v._v(" PoS")]),v._v(" "),l("p",[v._v("：权益证明（Proof of Stake），一个区块链的共识算法。")]),v._v(" "),l("ul",[l("li",[v._v("每个节点拥有的代币越多，则权益越大，有更大概率获得下一个区块的打包权。")]),v._v(" "),l("li",[v._v("与 PoW 相比，节省了运算成本。")])]),v._v(" "),l("h2",{attrs:{id:"一致性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[v._v("#")]),v._v(" 一致性")]),v._v(" "),l("p",[v._v("：Consistency ，指系统中不同节点拥有的数据副本一致（通常还应该是最新的数据）。")]),v._v(" "),l("ul",[l("li",[v._v("数据库的 ACID 指的是事务的一致性，而分布式系统中主要研究数据的一致性。")]),v._v(" "),l("li",[v._v("通常，需要各节点先达成共识，才能实现数据一致性。\n"),l("ul",[l("li",[v._v("不过数据不一致性时，各节点可能因为不同的数据副本而作出不同的决策，不容易达成共识。")])])]),v._v(" "),l("li",[v._v("每个写操作之后，如果等所有节点复制完新数据，才开始下一个读操作，则称为同步复制，否则称为异步复制。")]),v._v(" "),l("li",[v._v("常见的几种一致性模型：\n"),l("ul",[l("li",[v._v("强一致性：采用同步复制，保证各节点的一致性。\n"),l("ul",[l("li",[v._v("严格一致性（Strict consistency）\n"),l("ul",[l("li",[v._v("：每个写操作之后，各节点会立即变为一致，即实时复制。比如将写操作复制到各节点上同时执行。")])])]),v._v(" "),l("li",[v._v("顺序一致性（Sequential consistency）\n"),l("ul",[l("li",[v._v("：当程序发出多个读写操作时，各节点会按相同顺序执行这些操作。因此某些节点可能因为执行慢而数据滞后，但顺序并不会出错。")])])]),v._v(" "),l("li",[v._v("线性一致性\n"),l("ul",[l("li",[v._v("：具有实时性的顺序一致性，各节点同时遵守相同顺序。每个写操作在所有节点都生效之后，才会开始下一个操作。")]),v._v(" "),l("li",[v._v("又称为可线性化（Linearizability）、原子一致性。")]),v._v(" "),l("li",[v._v("强弱程度：严格一致性 > 线性一致性 > 顺序一致性")])])])])]),v._v(" "),l("li",[v._v("弱一致性：采用异步复制，因此各节点可能不一致。\n"),l("ul",[l("li",[v._v("因果一致性（Causal consistency）\n"),l("ul",[l("li",[v._v("：具有因果关系的多个操作（比如读写同一个数据），才保证顺序一致性，而其它并发操作则不限制。")])])]),v._v(" "),l("li",[v._v("最终一致性（Eventual consistency）\n"),l("ul",[l("li",[v._v("：允许各节点暂时不一致，但保证在一定时间内实现一致。")])])])])])])])]),v._v(" "),l("h2",{attrs:{id:"可用性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#可用性"}},[v._v("#")]),v._v(" 可用性")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("服务可用（Available）")]),v._v(" "),l("ul",[l("li",[v._v("：指客户端发出请求时，能收到正常的响应。\n"),l("ul",[l("li",[v._v("响应时长不能超过正常范围。")]),v._v(" "),l("li",[v._v("响应的内容不能是错误的，但可以不是最新的数据。")])])]),v._v(" "),l("li",[v._v("服务不可用时，又称为服务中断、故障。")])])]),v._v(" "),l("li",[l("p",[v._v("可用性（Availability）")]),v._v(" "),l("ul",[l("li",[v._v("：又称为可用率。如果服务可用的时长，占提供服务的总时长的比例接近 100% ，则称为可用性高，否则称为可用性低。")]),v._v(" "),l("li",[v._v("采用负载均衡、健康检查等措施可以实现服务的高可用性（High Availability，HA）。")])])]),v._v(" "),l("li",[l("p",[v._v("SLA （Service Level Agreement ，服务等级协议）")]),v._v(" "),l("ul",[l("li",[v._v("：由服务提供商承诺的服务质量指标，如果未达到则给客户一定赔偿。")]),v._v(" "),l("li",[v._v("比如承诺服务的全年可用性为 99% ，即不可用的时长低于 3.65 天；全年可用性为 99.9% ，即不可用时长低于 0.365*24=8.76 小时。")])])]),v._v(" "),l("li",[l("p",[v._v("提高系统性能的常见方案：")]),v._v(" "),l("ul",[l("li",[v._v("垂直扩展：增加单个服务的性能，比如增加服务器的 CPU 、内存等资源。")]),v._v(" "),l("li",[v._v("水平扩展：增加服务实例的数量，比如在一组服务器上分别部署一个服务实例。")])])])]),v._v(" "),l("h3",{attrs:{id:"常见问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[v._v("#")]),v._v(" 常见问题")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("单点故障（Single Point of Failure）")]),v._v(" "),l("ul",[l("li",[v._v("：单个模块不可用，导致整个服务不可用。或者单个服务不可用，导致整个系统不可用。")])])]),v._v(" "),l("li",[l("p",[v._v("级联故障（Cascading failure）")]),v._v(" "),l("ul",[l("li",[v._v("：上游服务故障，导致下游调用它的服务故障。")])])]),v._v(" "),l("li",[l("p",[v._v("服务雪崩")]),v._v(" "),l("ul",[l("li",[v._v("：级联故障导致大量服务不可用。")])])])]),v._v(" "),l("h3",{attrs:{id:"常见措施"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见措施"}},[v._v("#")]),v._v(" 常见措施")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("服务熔断")]),v._v(" "),l("ul",[l("li",[v._v("：当上游服务可用性降低时，下游服务停止调用它，避免级联故障。")]),v._v(" "),l("li",[v._v("服务熔断之后，下游服务可以拒绝提供服务，也可以开始服务降级。")])])]),v._v(" "),l("li",[l("p",[v._v("服务降级")]),v._v(" "),l("ul",[l("li",[v._v("：降低给客户端的响应质量，从而降低服务器的负载。")]),v._v(" "),l("li",[v._v("例如停止次要功能、延时处理请求、减少响应内容、使用旧的响应内容，甚至拒绝服务。")]),v._v(" "),l("li",[v._v("可以在配置平台增加一个参数开关，启用它则开始服务降级。")])])]),v._v(" "),l("li",[l("p",[v._v("服务限流")]),v._v(" "),l("ul",[l("li",[v._v("：属于服务降级，指服务限制一定时间内处理的请求数量，拒绝超过限制的请求，避免因为负载过大而故障。")])])])]),v._v(" "),l("h4",{attrs:{id:"健康检查"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#健康检查"}},[v._v("#")]),v._v(" 健康检查")]),v._v(" "),l("p",[v._v("：Health Check ，通过软件检查集群中各个服务器的状态，自动发现故障的服务器。")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("发现故障节点之后，需要及时将它下线，避免客户端访问它而服务不可用。或者通过重启等方式修复。")])]),v._v(" "),l("li",[l("p",[v._v("keepalived ：一个命令行工具，用于对多个服务器进行健康检查，自动去除故障服务器。")]),v._v(" "),l("ul",[l("li",[v._v("在集群的每个服务器上部署一份，相互之间通过 VRRP（Virtual Router Redundancy Protocol ，虚拟路由冗余协议）通信，实现路由的高可用。")]),v._v(" "),l("li",[v._v("工作在第三层时，是基于 ICMP 协议检查服务器是否在线。")]),v._v(" "),l("li",[v._v("工作在第四层时，是基于 TCP 协议检查服务器的端口是否开通。")]),v._v(" "),l("li",[v._v("工作在第七层时，是基于 HTTP 协议检查服务器是否正常工作。")])])])]),v._v(" "),l("h4",{attrs:{id:"负载均衡"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),l("p",[v._v("：Load Balance ，将服务器部署多个实例，用一个反向代理服务器接收所有客户端的访问流量，然后按特定的策略分发给各个实例。")]),v._v(" "),l("ul",[l("li",[v._v("优点：\n"),l("ul",[l("li",[v._v("容易横向扩容。")]),v._v(" "),l("li",[v._v("均衡各个服务器的负载压力，降低单点故障的风险。")]),v._v(" "),l("li",[v._v("有的负载均衡服务器能对各个服务器进行健康检查，避免将流量转发给故障的服务器，从而避免单点故障。")])])])]),v._v(" "),l("h2",{attrs:{id:"分区容错性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#分区容错性"}},[v._v("#")]),v._v(" 分区容错性")]),v._v(" "),l("p",[v._v("：Partition tolerance ，指系统出现网络分区时，能否继续提供服务。")]),v._v(" "),l("ul",[l("li",[v._v("如果任意两个节点之间不能在指定时间内将数据同步一致（比如网络延迟较大、节点故障），则视作网络中断，出现了网络分区。")])]),v._v(" "),l("h2",{attrs:{id:"cap-定理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#cap-定理"}},[v._v("#")]),v._v(" CAP 定理")]),v._v(" "),l("p",[v._v("：一个流行的理论，认为在分布式系统中，一致性（C）、可用性（A）、分区容错性（P） 三种性能通常不能同时满足，最多满足两种。")]),v._v(" "),l("ul",[l("li",[v._v("假设分布式系统中存在两个节点 N1、N2 ，两者的网络通信必然存在一定延迟。先在 N1 处写入数据 D ，然后在 N2 处读取数据 D 。此时：\n"),l("ul",[l("li",[v._v("如果 N2 等同步 N1 的数据之后再返回响应，则满足了 C ，但不满足 A 。")]),v._v(" "),l("li",[v._v("如果 N2 不同步 N1 的数据就返回响应，则必然是错误的响应，满足了 A ，但不满足 C 。")]),v._v(" "),l("li",[v._v("如果 N1 或 N2 因为网络分区而不能提供服务，则满足了 C ，但不满足 A、P 。")])])])])])}),[],!1,null,null,null);_.default=t.exports},660:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this.$createElement,_=this._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[_("h1",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[this._v("#")]),this._v(" 简介")])])}),[],!1,null,null,null);_.default=t.exports},666:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),l("h2",{attrs:{id:"消息队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),l("p",[v._v("：（Message Queue ，MQ），一种用于程序之间通信的中间件，可以暂存消息。先由发送方将消息放入消息队列，再由接收方从中获取消息。")]),v._v(" "),l("ul",[l("li",[v._v("优点：\n"),l("ul",[l("li",[v._v("解耦    ：每个程序只需要考虑对 MQ 的访问，不必直接与其它程序通信，因此耦合度低。")]),v._v(" "),l("li",[v._v("异步    ：消息的发送方和接收方异步工作，避免了等待对方回复的时间。")]),v._v(" "),l("li",[v._v("削峰    ：即使发送方突然发出了大量消息，接收方也依然是按照自己的速度从 MQ 获取消息，因此可以削弱消息数量的峰值。")])])]),v._v(" "),l("li",[v._v("缺点：\n"),l("ul",[l("li",[v._v("增加了系统的规模，需要多考虑一个中间件。")]),v._v(" "),l("li",[v._v("需要考虑一致性问题，保证消息不会被重复发布、消费。")]),v._v(" "),l("li",[v._v("需要考虑收发消息的顺序。")])])]),v._v(" "),l("li",[v._v("提供 MQ 服务的软件有多种，大多借鉴了 JMS 规范。")])]),v._v(" "),l("p",[v._v("使用消息队列的主要难点：")]),v._v(" "),l("ul",[l("li",[v._v("如何保证消息不被重复消费\n"),l("ul",[l("li",[v._v("可以给每个消息分配一个唯一 ID ，客户端记录自己获得的所有消息 ID ，如果收到重复的消息就忽略。或者服务器记录每个客户端获得的所有消息 ID ，不发送重复的消息。")])])]),v._v(" "),l("li",[v._v("如何保证不丢失消息\n"),l("ul",[l("li",[v._v("可能原因：客户端发布或接收消息时丢失、消息队列存储消息时丢失。")])])])]),v._v(" "),l("h2",{attrs:{id:"jms"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#jms"}},[v._v("#")]),v._v(" JMS")]),v._v(" "),l("p",[v._v("JMS（Java Message Service ，Java 消息服务）：Java 平台上消息中间件的 API 规范。")]),v._v(" "),l("p",[v._v("基本概念：")]),v._v(" "),l("ul",[l("li",[v._v("客户端          ：连接到 MQ 服务器的程序，可以作为消息的发送方（Sender）或接收方（Receiver）。")]),v._v(" "),l("li",[v._v("消息            ：程序之间的通信内容。")])]),v._v(" "),l("p",[v._v("JMS 定义了两种传输消息的模式：")]),v._v(" "),l("ul",[l("li",[v._v("点对点模式（Point to Point ，P2P）：一条消息只能被一个客户端接收。\n"),l("ul",[l("li",[v._v("消息的发送方、接收方分别称为生产者（Producer）、消费者（Consumer）。")]),v._v(" "),l("li",[v._v("Producer 将消息发送到某个队列（Queue）中，而消费者到某个 Queue 中获取消息（该过程称为消费）。")]),v._v(" "),l("li",[v._v("队列会长时间保存消息，直到它被消费或超时。")])])]),v._v(" "),l("li",[v._v("发布/订阅模式（Pub/Sub)：一条消息可以被多个客户端接收。\n"),l("ul",[l("li",[v._v("消息的发送方、接收方分别称为发布者（Publisher）、订阅者（Subscriber）。")]),v._v(" "),l("li",[v._v("Publisher 将消息发布到某个主题（Topic）下，而 MQ 会立即将该消息推送给订阅该 Topic 的所有 Subscriber 。")]),v._v(" "),l("li",[v._v("一个 Subscriber 可以订阅任意个 Topic ，但是只会收到订阅之后新发布的消息，不会收到历史消息，因为 MQ 不会长时间保存消息。")])])])]),v._v(" "),l("h2",{attrs:{id:"常见的消息队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见的消息队列"}},[v._v("#")]),v._v(" 常见的消息队列")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("ActiveMQ")])]),v._v(" "),l("li",[l("p",[v._v("RabbitMQ")]),v._v(" "),l("ul",[l("li",[v._v("采用 erlang 开发，实现了高级消息队列（Advanced Message Queuing Protocol ，AMQP）协议。")]),v._v(" "),l("li",[v._v("并发能力强，延迟很低。")]),v._v(" "),l("li",[v._v("生产者发送的消息，会由 exchange（交换机）转发到某个或某些队列。")])])]),v._v(" "),l("li",[l("p",[v._v("RocketMQ")]),v._v(" "),l("ul",[l("li",[v._v("采用 Java 开发，由阿里巴巴公司开源，捐献给了 ASF 。")]),v._v(" "),l("li",[v._v("它借鉴了 Kafka ，但功能更强。")])])]),v._v(" "),l("li",[l("p",[v._v("Kafka")])])])])}),[],!1,null,null,null);_.default=t.exports},673:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),l("h2",{attrs:{id:"存储类型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#存储类型"}},[v._v("#")]),v._v(" 存储类型")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("块存储")]),v._v(" "),l("ul",[l("li",[v._v("：不管数据内容，只管提供一定容量的存储空间。")]),v._v(" "),l("li",[v._v("比如硬盘等块设备。")])])]),v._v(" "),l("li",[l("p",[v._v("文件存储")]),v._v(" "),l("ul",[l("li",[v._v("：按目录树存储文件，每个文件通过唯一的路径寻址。")]),v._v(" "),l("li",[v._v("主要用于存储非结构化数据，比如视频、图片，而结构化数据通常用数据库存储。")]),v._v(" "),l("li",[v._v("比如 FTP、HTTP、NFS 等服务器。")])])]),v._v(" "),l("li",[l("p",[v._v("对象存储")]),v._v(" "),l("ul",[l("li",[v._v("：将文件以 key-value 形式存储。\n"),l("ul",[l("li",[v._v("用文件名作为 key ，不使用目录树，这样可以避免路径寻址的耗时。")]),v._v(" "),l("li",[v._v("用文件内容作为 value ，且分成多个部分存储，这样可以通过并行读写提高访问速度，但不支持修改文件。")])])]),v._v(" "),l("li",[v._v("Amazon S3（Simple Storage Service）是目前最流行的对象存储协议，用户可通过 RESTful API 或 aws 命令进行访。")]),v._v(" "),l("li",[v._v("对象存储是新一代的存储方案，介于块存储与文件存储之间，优点较多，但成本也较高。")])])])]),v._v(" "),l("h2",{attrs:{id:"相关软件"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#相关软件"}},[v._v("#")]),v._v(" 相关软件")]),v._v(" "),l("ul",[l("li",[v._v("Ceph ：同时支持块存储、文件存储、对象存储。")]),v._v(" "),l("li",[v._v("GlusterFS ：用于文件存储。2011 年被红帽公司收购。")]),v._v(" "),l("li",[v._v("GoogleFS ：用于文件存储。由 Google 开发，闭源。")]),v._v(" "),l("li",[v._v("HDFS ：用于文件存储，借鉴了 GoogleFS 。")]),v._v(" "),l("li",[v._v("FastDFS ：用于文件存储。")]),v._v(" "),l("li",[v._v("Swift ：用于对象存储。")]),v._v(" "),l("li",[v._v("MinIO ：用于对象存储。")])]),v._v(" "),l("h3",{attrs:{id:"nfs"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#nfs"}},[v._v("#")]),v._v(" NFS")]),v._v(" "),l("p",[v._v("：网络文件系统（Network File System），一个用于共享文件系统的网络协议，工作在表示层。")]),v._v(" "),l("ul",[l("li",[v._v("1984 年由 Sun 公司发布。")]),v._v(" "),l("li",[v._v("采用 C/S 架构。\n"),l("ul",[l("li",[v._v("客户端需要通过 RPC 协议访问服务器的 UDP 111 端口，查询到 NFS 各项服务进程当前监听的端口，然后与其建立 TCP 连接。")]),v._v(" "),l("li",[v._v("客户端可以挂载服务器上共享的文件系统，直接读写其中的文件，像读写本机文件一样方便。")])])])]),v._v(" "),l("h3",{attrs:{id:"iscsi"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#iscsi"}},[v._v("#")]),v._v(" iSCSI")]),v._v(" "),l("p",[v._v("：因特网小型计算机系统接口（Internet Small Computer System Interface），一个用于共享存储设备的网络协议。")]),v._v(" "),l("ul",[l("li",[v._v("2003 年由 IBM 公司发布。")]),v._v(" "),l("li",[v._v("采用 C/S 架构，基于 TCP/IP 协议通信。")]),v._v(" "),l("li",[v._v("比 NFS 更底层，可以将远程主机的存储设备（比如磁盘）挂载到本机。\n"),l("ul",[l("li",[v._v("原理：将本机发出的 SCSI 命令，传输到远程主机上执行。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);